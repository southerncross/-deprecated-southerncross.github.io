<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>从零开始搭建 Express + Vue 开发环境 · Shunyang Li's blog</title><meta name="description" content="从零开始搭建 Express + Vue 开发环境 - Shunyang Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><h1>Shunyang Li's blog</h1></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/southerncross" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">从零开始搭建 Express + Vue 开发环境</h1><div class="post-meta"><div class="post-time">2016年2月28日</div></div><div class="post-content"><p>完整的代码已经上传 Github，<a href="https://github.com/southerncross/vue-express-dev-boilerplate" target="_blank" rel="external">点击访问</a></p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-__u4E3A_u524D_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177_u548C_u8D44_u6E90_u7BA1_u7406_u5DE5_u5177"><a href="#1-__u4E3A_u524D_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177_u548C_u8D44_u6E90_u7BA1_u7406_u5DE5_u5177" class="headerlink" title="1. 为前端选择合适的预处理工具和资源管理工具"></a>1. 为前端选择合适的预处理工具和资源管理工具</h3><p>预处理工具又分为 js 预处理工具和 css 预处理工具。Javascript 一直以来最为人诟病的一点就是缺乏原生的模块机制，所有 js 代码文件在被 html 页面引入后将共用同一个命名空间。所以才出现了各种“标准”尝试解决这个问题，但他们都不是原生的，需要额外的工具对代码进行特殊处理。虽然 ES6 终于引入了模块机制，但以现在的浏览器支持程度，还不足以“毫无顾虑地随拿随用”。所以 js 预处理工具最主要的工作就是帮助解决 js 的模块问题。而 css 预处理工具则很好理解，就是把 sass，less 或者 stylus 代码翻译、合并成 css 代码。</p>
<p>资源管理工具则是帮我们管理前端所需的各种资源文件（比如 css、js、图片、字体等等），便于我们引用。目前常用的解决方法是将他们直接编码进 js 代码中，然后像引用 js 模块一样引用它们。这可比手写各种 url 方便多了。</p>
<p>正如标题所说，我们将采用 Webpack，因为它具备上面所说的所有功能。此外还支持代码热替换，使修改代码后不用刷新页面也能在浏览器中立即看到效果。</p>
<p><img src="http://webpack.github.io/assets/what-is-webpack.png" alt="Webpack schedule"></p>
<h3 id="2-__u4E3A_u540E_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177"><a href="#2-__u4E3A_u540E_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177" class="headerlink" title="2. 为后端选择合适的预处理工具"></a>2. 为后端选择合适的预处理工具</h3><p>后端面对的都是 js 代码，不需要前端那样的资源管理工具，另外， Node 强迫你使用至少一种模块管理方案（CommonJS 或 ES6 的 import），也不用考虑代码的依赖问题。</p>
<p>所以后端要简单许多，唯一需要考虑的基本上就剩下如何将 ES6 转译成 ES5 了（如果你打算使用 ES6 的话）。目前常用的做法是使用 Babel，你可以用 Babel 命令行工具独立执行编译过程，也可以配置 Babel register 实现代码运行时动态翻译，这对于开发场景而言无疑是最方便的。所以我们选择后一种方式。</p>
<p><img src="https://babeljs.io/images/logo.svg" alt="Babel logo"></p>
<h3 id="3-__u4E3A_u6574_u4E2A_u9879_u76EE_u9009_u62E9_u5408_u9002_u7684_u6D41_u7A0B_u63A7_u5236_u5DE5_u5177"><a href="#3-__u4E3A_u6574_u4E2A_u9879_u76EE_u9009_u62E9_u5408_u9002_u7684_u6D41_u7A0B_u63A7_u5236_u5DE5_u5177" class="headerlink" title="3. 为整个项目选择合适的流程控制工具"></a>3. 为整个项目选择合适的流程控制工具</h3><p>流程控制工具是为了帮助我们管理诸如代码检查、编译、压缩、移动、部署这些任务的，原本我们是通过手敲命令（或者高级一点写个脚本）的方式做，有了流程控制工具以后，只需要提供配置文件和少量代码就可以完成。</p>
<p>目前最流行的解决方案是 gulp。不过，由于我们这里要搭建的是开发环境，没有移动代码、压缩、部署等需求，所以不需要功能强大的 gulp。我们只要用 nodemon 这个工具监听代码变动然后适时重启 server就够了。</p>
<p><img src="https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667" alt="Nodemon logo"></p>
<h2 id="u6B63_u5F0F_u5F00_u59CB_u642D_u5EFA"><a href="#u6B63_u5F0F_u5F00_u59CB_u642D_u5EFA" class="headerlink" title="正式开始搭建"></a>正式开始搭建</h2><h3 id="1-__u5229_u7528_Express__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528"><a href="#1-__u5229_u7528_Express__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528" class="headerlink" title="1. 利用 Express 脚手架快速搭建应用"></a>1. 利用 Express 脚手架快速搭建应用</h3><p>使用 Express 提供的脚手架工具（<a href="http://expressjs.com/en/starter/generator.html" target="_blank" rel="external">Express application generator</a>）可以在 1s 之内搭建出最基本的应用。</p>
<p>如果你以前还没试过，首先执行下面的命令安装</p>
<p><code>npm install express-generator -g</code></p>
<p>然后执行以下命令生成代码，命令执行过程中需要输入一些参数。</p>
<p><code>express &lt;myapp&gt;</code></p>
<p>完成后的文件结构是这样的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app<span class="class">.js</span></span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package<span class="class">.json</span></span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style<span class="class">.css</span></span><br><span class="line">├── routes</span><br><span class="line">│   ├── index<span class="class">.js</span></span><br><span class="line">│   └── users<span class="class">.js</span></span><br><span class="line">└── views</span><br><span class="line">    ├── error<span class="class">.jade</span></span><br><span class="line">    ├── index<span class="class">.jade</span></span><br><span class="line">    └── layout.jade</span><br></pre></td></tr></table></figure>
<p>但是这个文件结构只是后端代码，要想跟前端代码相结合，需要做一些改动。我们计划最终的文件结构应该是这样的</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line">│   ├── <span class="keyword">client</span></span><br><span class="line">│   └── <span class="keyword">server</span></span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>所以需要将上面自动生成的 Express 代码放到 /src/server/ 路径下。</p>
<p>接下来我们要删除一些用不着的东西以及增加一些缺失的东西。</p>
<p>首先，由于我们打算在前端使用 Vue 框架，并由 Vue-Router 管理大部分路由，后端 Express 仅保留少量的 RESTful API 路由，所以后端不需要复杂的路由设置，那么 routes 文件夹下的内容可以简化成一个 routers.js 文件。</p>
<p>然后，我们需要配置好 Babel register，所以需要在项目跟路径下新增两个文件 <code>.babelrc</code> 和 <code>index.js</code>，内容分别为：</p>
<p>/.babelrc<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">presets</span>": <span class="value">[<span class="string">"es2015"</span>]</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>.babelrc 是 Babel 6.0 必须的文件</p>
<p>/.index.js<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'babel-register'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'./src/server'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面两句完成 Bebel 注册，它会爬取所有 <code>require</code> 或 <code>import</code> 方式依赖的模块并把它们翻译成 ES5。</p>
<p>自动生成的代码里有个 www 文件，他是 Express 应用的入口文件，我们把它放在 server 路径下并改名为 index.js 以便让上面配置的 Babel register 能正确找到它。</p>
<blockquote>
<p>为什么要改名为 index.js ？这是因为 <code>require(&#39;./src/server&#39;)</code> 在默认情况下会去找 ./src/server/index.js，如果你想用别的名字，那就记得将 Babel register 的配置文件里改为 <code>require(./src/&lt;your entry file&gt;</code>。</p>
</blockquote>
<p>好了，现在后端的事情先暂时告一段落，接下来看看前端。</p>
<h3 id="2-__u5229_u7528_Vue__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528"><a href="#2-__u5229_u7528_Vue__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528" class="headerlink" title="2. 利用 Vue 脚手架快速搭建应用"></a>2. 利用 Vue 脚手架快速搭建应用</h3><p>同样地，推荐使用 Vue 自带的 <a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">template 工具</a>，在 1s 内生成基本代码。</p>
<p>虽然利用这个工具生成的代码的后端就是基于 Express 的，但是后端部分的代码结构太简单，不适合做后续开发。所以建议这里先将 Vue 生成的代码放在另外一个地方，然后按需移动到前面用 Express 生成的代码文件夹里。</p>
<p>首先安装 template 工具</p>
<p><code>npm install -g vue-cli</code></p>
<p>然后执行命令生成代码。命令执行过程中需要输入一些参数</p>
<p><code>vue init webpack &lt;my-project&gt;</code></p>
<p>生成的代码结构是这样的</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── dev-<span class="keyword">server</span>.js         <span class="preprocessor"># development server script</span></span><br><span class="line">│   ├── karma.conf.js         <span class="preprocessor"># unit testing config</span></span><br><span class="line">│   ├── webpack.base.conf.js  <span class="preprocessor"># shared base webpack config</span></span><br><span class="line">│   ├── webpack.dev.conf.js   <span class="preprocessor"># development webpack config</span></span><br><span class="line">│   ├── webpack.prod.conf.js  <span class="preprocessor"># production webpack config</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.js               <span class="preprocessor"># app entry file</span></span><br><span class="line">│   ├── App.vue               <span class="preprocessor"># main app component</span></span><br><span class="line">│   ├── components            <span class="preprocessor"># ui components</span></span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── assets                <span class="preprocessor"># module assets (processed by webpack)</span></span><br><span class="line">│       └── ...</span><br><span class="line">├── <span class="keyword">static</span>                    <span class="preprocessor"># pure static assets (directly copied)</span></span><br><span class="line">├── dist                      <span class="preprocessor"># built files ready for deploy</span></span><br><span class="line">├── test</span><br><span class="line">│   └── unit                  <span class="preprocessor"># unit tests</span></span><br><span class="line">│       ├── <span class="keyword">index</span>.js          <span class="preprocessor"># unit test entry file</span></span><br><span class="line">│       └── ...</span><br><span class="line">├── .babelrc                  <span class="preprocessor"># babel config</span></span><br><span class="line">├── .eslintrc.js              <span class="preprocessor"># eslint config</span></span><br><span class="line">├── <span class="keyword">index</span>.html                <span class="preprocessor"># main html file</span></span><br><span class="line">└── package.json              <span class="preprocessor"># build scripts and dependencies</span></span><br></pre></td></tr></table></figure>
<p>我们发现这里也有一个 .babelrc，内容跟之前自己创建的基本一致，可以忽略它。此外，它还提供了 .eslintrc.js，是为了配合 eslint 检查代码是否符合规范的。这里面的内容很简单，想要偷懒就直接拿过来，觉得定制的规则不太符合自己的习惯的可以另外配置。</p>
<p>然后看到 build 路径下有 3 个 webpack 有关的配置文件，因为我们是要搭建开发环境，所以挑里面的 webpack.base.conf.js 和 webpack.dev.conf.js 就可以，建议把内容合并到一个 webpack.conf.js 文件里，放在项目的根目录下。</p>
<p>之后，基本上就是把 src 目录移动到之前用 Express 创建的 /src/client/，我习惯将所有 js 的入口文件都改为 index.js 所以，这里也可以将 src/client/main.js 改名为 src/client/index.js。</p>
<p>其他的文件先忽略不管。</p>
<p>到这里，前端部分的代码也基本整理完毕了。</p>
<h3 id="3-__u914D_u7F6E_Webpack"><a href="#3-__u914D_u7F6E_Webpack" class="headerlink" title="3. 配置 Webpack"></a>3. 配置 Webpack</h3><p>我们计划让 Webpack 将前端文件打包成一个 build.js 文件，然后放在 /src/server/public/javascripts 中供 jade 模板使用。所以设置好 webpack 的路径部分（其他的保留原来的就好）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'src/client/index.js'</span>),</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'src/server/public/javascripts/'</span>),</span><br><span class="line">      publicPath: <span class="string">'/javascripts/'</span>,</span><br><span class="line">      filename: <span class="string">'build.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于如何启动 Webpack，你可以选择单独用一个 shell 窗口运行它，也可以以 Express 中间件的形式提供代理。采用后一种方式，webpack 并不会把打包好的代码生成在磁盘上，而是保留在内存里。我们选择后一种方式，因为更方便。</p>
<blockquote>
<p>只应该在开发环境中以 Express 中间件的形式部署 Webpack</p>
</blockquote>
<p>所以需要修改 /src/server/index.js，关键是增加这几句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">'webpack'</span></span><br><span class="line"><span class="keyword">import</span> webpackDevMiddleware <span class="keyword">from</span> <span class="string">'webpack-dev-middleware'</span></span><br><span class="line"><span class="keyword">import</span> webpackHotMiddleware <span class="keyword">from</span> <span class="string">'webpack-hot-middleware'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../../webpack.config'</span></span><br><span class="line"></span><br><span class="line">const compiler = webpack(config)</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: config.output.publicPath,</span><br><span class="line">  stats: &#123; colors: true &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use(webpackHotMiddleware(compiler))</span><br></pre></td></tr></table></figure>
<p>这样每次启动 Express 后，Webpack 中间件会拦截 config.output.publicPath 地址的请求并返回正确的结果，同时，如果被 Webpack 监听的文件发生变动，会立即通知前端产生相应变化。</p>
<h3 id="4-__u914D_u7F6E_Nodemon"><a href="#4-__u914D_u7F6E_Nodemon" class="headerlink" title="4. 配置 Nodemon"></a>4. 配置 Nodemon</h3><p>之前提到过，计划用 Nodemon 启动 server 并监听代码变动。而 Nodemon 默认会监听除了 .git 和 node_modules 路径外的所有 js 代码，因为我们已经有 Webpack 监听前端代码了，所以得做相关配置让 Nodemon 只监听某一块代码。</p>
<p>在项目根路径下新增文件 nodemon.json，内容为</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">verbose</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">  "<span class="attribute">ignore</span>": <span class="value">[<span class="string">"src/server/public/"</span>]</span>,</span><br><span class="line">  "<span class="attribute">events</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">restart</span>": <span class="value"><span class="string">"osascript -e 'display notification \"App restarted due to:\n'$FILENAME'\" with title \"nodemon\"'"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">watch</span>": <span class="value">[<span class="string">"src/server/"</span>]</span>,</span><br><span class="line">  "<span class="attribute">env</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">NODE_ENV</span>": <span class="value"><span class="string">"development"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">ext</span>": <span class="value"><span class="string">"js jade"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中，将 verbose 设置为 true 将打印更丰富的日志信息，对开发很有帮助。</p>
<p>我们选择让 Nodemon 监听 src/server/ 目录，并忽略 src/server/public 目录，因为那里是前端 webpack 生成打包文件的地方。注意我们是以 Express 中间件的形式使用 Webpack，并不会在磁盘上真的产生文件，所以这个 ignore 规则其实可以省略。</p>
<p>别忘了在文件扩展名中增加 jade 类型，因为 Express 使用的是 jade 模板。</p>
<h3 id="5-__u914D_u7F6E_package-json"><a href="#5-__u914D_u7F6E_package-json" class="headerlink" title="5. 配置 package.json"></a>5. 配置 package.json</h3><p>首先在 script 中增加一个命令，用来启动整个应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"nodemon index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，只需要运行 <code>npm run dev</code> 这一个命令就可以启动 server 同时进行开发了。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/02/14/how-to-use-h1-h2-h3/" class="next">下一篇</a></div><div data-thread-key="2016/02/28/setup-express-vue-boilerplate/" data-title="从零开始搭建 Express + Vue 开发环境" data-url="http://southerncross.github.io/2016/02/28/setup-express-vue-boilerplate/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"lishunyang.duoshuo.com"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://southerncross.github.io">Shunyang Li</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>