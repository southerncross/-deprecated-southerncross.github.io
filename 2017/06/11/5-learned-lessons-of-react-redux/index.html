<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>5个有关react-redux的心得 · Shunyang Li's blog</title><meta name="description" content="5个有关react-redux的心得 - Shunyang Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><h1>Shunyang Li's blog</h1></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/southerncross" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">5个有关react-redux的心得</h1><div class="post-meta"><div class="post-time">2017年6月11日</div></div><div class="post-content"><h2 id="Action-Type-尽量保持与业务逻辑无关，Action-Creator-可以与业务逻辑有关"><a href="#Action-Type-尽量保持与业务逻辑无关，Action-Creator-可以与业务逻辑有关" class="headerlink" title="Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关"></a>Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关</h2><p>action 应该尽可能细粒度，做小的、与业务无关的事情；在action creator中对action进行组合，复用。</p>
<p>举个例子，假设你需要一个更新用户名的 API，可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUserName</span>(<span class="params">userId, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    request.put(<span class="string">'/api/user-name/'</span> + userId)</span><br><span class="line">    .then(<span class="function">(<span class="params">user</span>) =&gt;</span> dispatch(&#123;</span><br><span class="line">      type: UPDATE_ONE_USER,</span><br><span class="line">      payload: &#123; user &#125;,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> UPDATE_ONE_USER: <span class="keyword">return</span> &#123; ...state, <span class="attr">user</span>: action.payload.user &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，假如未来需要新增其他更新用户信息的API（比如变更权限），那么所要做的只是新增一个action creator，复用以前的action type即可。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUserPermission</span>(<span class="params">userId, permission</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    request.put(<span class="string">'/api/user-permission/'</span> + userId)</span><br><span class="line">    .then(<span class="function">(<span class="params">user</span>) =&gt;</span> dispatch(&#123;</span><br><span class="line">      type: UPDATE_ONE_USER,</span><br><span class="line">      payload: &#123; user &#125;,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非共享的、局部的、UI-only的状态，不一定非要放在redux-state中"><a href="#非共享的、局部的、UI-only的状态，不一定非要放在redux-state中" class="headerlink" title="非共享的、局部的、UI only的状态，不一定非要放在redux state中"></a>非共享的、局部的、UI only的状态，不一定非要放在redux state中</h2><p>最典型的例子是loading状态。每个API都有独立的loading状态，甚至同一个API的每次调用都是独立的loading状态。在redux中记录这些loading信息是一件挺吃力不讨好的事情。因为首先正确记录loading状态就不是个容易的事情，很可能必须得用<code>API名字 + 参数</code>为key来记录，在使用的时候也必须小心地使用<code>API名字 + 参数</code>去拿到这个值。其次，这些loading状态可能只是一个component需要的局部UI状态，当API请求结束，loading状态的使命也宣告结束，没有存在的必要了，也就不应该存在redux里。</p>
<p>遇到这种问题，建议把loading放在Component内部的state中，用callback触发setState，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateUserName</span>(<span class="params">userId, name, callback = (</span>) =&gt; </span>&#123;&#125;) &#123; <span class="comment">// 注意多了一个callback参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    request.put(<span class="string">'/api/user-name/'</span> + userId)</span><br><span class="line">    .then(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">      callback();</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: UPDATE_ONE_USER,</span><br><span class="line">        payload: &#123; user &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> callback(err));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体在用的时候结合this.setState</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  updateUserName(userId, name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">isUpdating</span>: <span class="literal">true</span> &#125;); <span class="comment">// &lt;-- loading开始</span></span><br><span class="line">    <span class="keyword">this</span>.props.updateUserName(userId, name, (err) =&gt; &#123; <span class="comment">// 通过callback调用setState</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">isUpdating</span>: <span class="literal">false</span> &#125;); <span class="comment">// &lt;-- loading结束</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="entities足以，idList慎用"><a href="#entities足以，idList慎用" class="headerlink" title="entities足以，idList慎用"></a>entities足以，idList慎用</h2><p>entities指的是一种map数据结构，内容为 id -&gt; data。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userEntities = &#123;</span><br><span class="line">  [user1.id]: user1,</span><br><span class="line">  [user2.id]: user2,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jobEntities = &#123;</span><br><span class="line">  [job1.id]: job1,</span><br><span class="line">  [job2.id]: job2,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于列表数据，一种常见的做法是用entities存储数据，然后用idList来表示顺序。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">userEntities = &#123;</span><br><span class="line">  <span class="number">1</span>: user1,</span><br><span class="line">  <span class="number">2</span>: user2,</span><br><span class="line">  <span class="number">3</span>: user3,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ascIdList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 顺序排列</span></span><br><span class="line">descIdList = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]; <span class="comment">// 逆序排列</span></span><br><span class="line">myIdList = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]; <span class="comment">// 其他特殊的排列顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// render的时候只要按照idList进行map即可：</span></span><br><span class="line">ascUsers = ascIdList.map(<span class="function">(<span class="params">id</span>) =&gt;</span> userEntities[id]);</span><br><span class="line">descUsers = descIdList.map(<span class="function">(<span class="params">id</span>) =&gt;</span> userEntities[id]);</span><br><span class="line">myUsers = myIdList.map(<span class="function">(<span class="params">id</span>) =&gt;</span> userEntities[id]);</span><br></pre></td></tr></table></figure>
<p>这种组织state的方式有一个最大的问题，那就是当涉及到数据变化的时候，所有相关的idList也需要改动，不然就会发生问题。比如删掉了id是2的user，那么三个idList都要做一遍filter，去掉2。</p>
<p>为了避免这种数据改动导致idList被牵连改动的问题，另一种做法是完全不用idList，而是在使用的地方就地排序。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">userEntities = &#123;</span><br><span class="line">  <span class="number">1</span>: user1，</span><br><span class="line">  <span class="number">2</span>: user2,</span><br><span class="line">  <span class="number">3</span>: user3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有idList，用到的时候现场排序</span></span><br><span class="line">ascUser = <span class="built_in">Object</span>.keys(userEntities).sort(ascCompare).map(<span class="function">(<span class="params">id</span>) =&gt;</span> userEntities[id]);</span><br><span class="line">descUser = <span class="built_in">Object</span>.keys(userEntities.sort(descCompare).map(<span class="function">(<span class="params">id</span>) =&gt;</span> userEntities[id]);</span><br><span class="line">myUser = <span class="built_in">Object</span>.keys(userEntities.sort(myCompare).map(<span class="function">(<span class="params">id</span>) =&gt;</span> userEntities[id]);</span><br></pre></td></tr></table></figure>
<p>不过呢，上面这个做法虽然避免了idList的牵连改动，但每次使用的时候都要sort，性能上有一定影响。没关系，这个可以用memoized function解决。比如使用reselect。</p>
<p>所以，大部分时候用entities就够了，引入idList可能会更麻烦</p>
<h2 id="只要你愿意，什么组件都可以connect到redux-store"><a href="#只要你愿意，什么组件都可以connect到redux-store" class="headerlink" title="只要你愿意，什么组件都可以connect到redux store"></a>只要你愿意，什么组件都可以connect到redux store</h2><p>redux 作者推荐的一种使用redux的方式是将connect用作container组件，将具体的render逻辑放在presentation组件中。这样，data source和data presentation就可以解耦，便于替换和复用。</p>
<p>理论上，只要你愿意，任何组件只要connect到redux store，就可以做container组件。然而很多人认为选择哪些组件做container是十分有讲究的。有些人认为只有顶层组件才是container组件，例如APP组件；有些人认为router组件算是container组件。哪一种是对的呢？</p>
<p>回到问题的根本，为什么我们要求不是所有组件都可以connect呢？主要原因还是便于测试，进而提高代码可靠性。当然也有一些性能上的考虑，但在大多数情况下，性能都不是主要考虑的问题。</p>
<p>所以，限制只有某些组件才能做container的做法，初衷是为了保证代码单元测试起来更加容易。这其实不是一个很强力的观点，因为99%前端工程都没有单元测试，强行用这种观点去实践，反而会给开发带来额外的麻烦。</p>
<p>也许你见过这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 container 组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MiddleComponent</span><br><span class="line">        a=&#123;<span class="keyword">this</span>.props.a&#125;</span><br><span class="line">        b=&#123;<span class="keyword">this</span>.props.b&#125;</span><br><span class="line">        c=&#123;<span class="keyword">this</span>.props.c&#125;</span><br><span class="line">        d=&#123;<span class="keyword">this</span>.props.d&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InnerComponent</span><br><span class="line">        a=&#123;<span class="keyword">this</span>.props.a&#125; <span class="comment">// &lt;-- a、b、c、d这些属性对MiddleComponent完全没有意义，只是原封不动地传给了InnerComponent</span></span><br><span class="line">        b=&#123;<span class="keyword">this</span>.props.b&#125;</span><br><span class="line">        c=&#123;<span class="keyword">this</span>.props.c&#125;</span><br><span class="line">        d=&#123;<span class="keyword">this</span>.props.d&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这种代码，我立刻就想到了“酒肉穿肠过，佛祖心中留”。借用王银曾经评论haskell的比喻，这就好比是一个没有无线电的世界，所有的信号传递都只能通过一根根电线链接两头。</p>
<p>为了避免上面那种壮丽的景象，有人选择这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InnerComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法看似简单了很多，但由于props的传递是隐式的，开发者要弄清究竟传了什么，就必须回溯到最开始的container组件。这就好比一些数学教材中的证明答案：由第xx题的证明结论，可以得到blablabla。但是你去看第XX题，发现也是一样的：由第YY题的证明结论可以得到blablabla。然后你又要去看YY题的证明过程，可能得到的还是类似的东西。。</p>
<p>再多说一句，凡是隐式的、动态的写法，基本都是有害的。因为写的时候你爽了，以后其他人维护代码的时候就会被坑惨了。</p>
<p>所以，不要迷信什么必须只有顶层容器才能connect之类的best practice，大胆connect吧，只要别再common组件里connect就行（common组件不要混入业务逻辑，也就不要connect）。</p>
<h2 id="避免嵌套过深的state结构"><a href="#避免嵌套过深的state结构" class="headerlink" title="避免嵌套过深的state结构"></a>避免嵌套过深的state结构</h2><p>这个道理很容易理解，越是嵌套深，越是不容易修改（因为要return新的state），不懂的话吃过亏也就懂了。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/05/09/study-plan/" class="prev">PRVE</a><a href="/2016/08/30/dingding-isv-development-tips/" class="next">NEXT</a></div><div data-thread-key="2017/06/11/5-learned-lessons-of-react-redux/" data-title="5个有关react-redux的心得" data-url="http://southerncross.github.io/2017/06/11/5-learned-lessons-of-react-redux/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"lishunyang.duoshuo.com"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2019 <a href="http://southerncross.github.io">Shunyang Li</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>