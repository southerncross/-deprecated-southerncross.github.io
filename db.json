{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1,"renderable":1},{"_id":"themes/apollo/source/favicon.jpg","path":"favicon.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1454336369000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1454336369000},{"_id":"themes/apollo/_config.yml","hash":"b79812185c908d675a536b90b1d37cde179afe65","modified":1454337141000},{"_id":"themes/apollo/README.md","hash":"a6930c691c69ed78584022fbcd0f4245587d09f5","modified":1454336369000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1454336369000},{"_id":"themes/apollo/package.json","hash":"9426138c09ebb95969021d951590c0c54b187a43","modified":1454336369000},{"_id":"source/_drafts/understand-ssh-port-forwarding.md","hash":"52b85bc981dd81ee52a0674f0cd3de02c79a6dfa","modified":1557455908654},{"_id":"source/_drafts/es6-proxy-and-reflect.md","hash":"523f1804f9399d48cd11c6df2aa38d43ff6277fa","modified":1459093915000},{"_id":"source/_drafts/setup-express-vue-production.md","hash":"39617711d122164ae15a78d0970f0fdf620e13b9","modified":1459092671000},{"_id":"source/_posts/5-learned-lessons-of-react-redux.md","hash":"beff6b617448943d6a6363b8ac3d82180e879f67","modified":1497150641000},{"_id":"source/_posts/dingding-isv-development-tips.md","hash":"80d399eb01cb9dd7b416e9c51b7fc614889428af","modified":1472571442000},{"_id":"source/_posts/how-to-use-h1-h2-h3.md","hash":"da7ea0637790d4419b8252fcb285397957a3338d","modified":1455947449000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1455456307000},{"_id":"source/_posts/meteor-qiniu-client-upload-example.md","hash":"5eab739b0b8b412e3aa3b4f43cb6b17e9ea2adf5","modified":1454337811000},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1454336369000},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1454336369000},{"_id":"source/_posts/study-plan.md","hash":"9d4e393fb2a50087e722977f078044f273a426ee","modified":1557455809078},{"_id":"source/_posts/setup-express-vue-boilerplate.md","hash":"0c1a9325d18f505212edefb1aa1eeae2a09d4a89","modified":1456650052000},{"_id":"themes/apollo/.git/index","hash":"6497a680557666fe19a0db15da70bb1e1f9a1db1","modified":1454336548000},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1454336362000},{"_id":"themes/apollo/.git/packed-refs","hash":"d7cbd744a14d9464fb4a01f923aeb73b70c1dced","modified":1454336369000},{"_id":"themes/apollo/doc/doc-en.md","hash":"1bccce1d01f085aedcb01317d2db23ca61351f13","modified":1454336369000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"3aad2ed65922f6f5dd9731301195474d16a8a9be","modified":1454336369000},{"_id":"themes/apollo/languages/en.yml","hash":"65998758dd27a350b6d4f2dc803970a9c89978da","modified":1454336369000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"4d65eeec01b5cfa7ab81363c089838c9dac827fb","modified":1454336369000},{"_id":"themes/apollo/layout/index.jade","hash":"58c451042cad5beeb5a76852bba609c651ff3428","modified":1454336369000},{"_id":"themes/apollo/layout/post.jade","hash":"33ab46ab3736e5d51388939858647942ce375b9b","modified":1454336369000},{"_id":"themes/apollo/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1454376229000},{"_id":"source/_posts/meteor-qiniu-client-upload-example/qiniu-upload-flow.png","hash":"717336a978f45881e2c3b7e65dad4740e28712d3","modified":1454317846000},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1454336362000},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1454336362000},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1454336362000},{"_id":"themes/apollo/.git/logs/HEAD","hash":"64037f515aad1386dd2255361eefe3197a5a8e9a","modified":1454336369000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"dea68e85b38069f4c096d1014b5d0f1f4a08ad81","modified":1454337066000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"b72514de242a999de85f7dcb09d883add94c5644","modified":1454337058000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"73a6ad5a2ff6c5e65c57b22052115e51c8b54890","modified":1454336369000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"2e2ee43c7241279a32b8c1386a2dea1409ef0e1c","modified":1454336369000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"e2a11f01ea0db5edf1f8b80f7563edd3231fa3b3","modified":1454337035000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"721dbc17fbae2a0f0395651a112363a23382602f","modified":1454337572000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"c35d3061da4b053b73150d9741c542d660798270","modified":1454336369000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"4c83fec1e2fc5cffefafc2e31835e28122c0fdfd","modified":1454336369000},{"_id":"themes/apollo/source/css/apollo.css","hash":"3769b55e027697d6d163ddf82b664b16c767ba9c","modified":1454336369000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"2f0ecd6ea1fec0aad4097dcb509b5ed5d1badd5c","modified":1454336369000},{"_id":"themes/apollo/.git/objects/pack/pack-b163e92f7706a44e02a5e0b1959ae02c59e61862.idx","hash":"39b7425a8b2a4f4f321798cb67455a822568f22b","modified":1454336369000},{"_id":"themes/apollo/.git/refs/heads/master","hash":"55f332a0b464f455b695296f007b93318a90a6fe","modified":1454336369000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"88b361e68475caddbab763feed5e1db788ac2cd7","modified":1454336369000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1454336369000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"7fc843c37a4dbf9f6e70770398841a73465ec642","modified":1454336369000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"4dd7650e40c6e3f754f88a9937ad0939b85f232d","modified":1454337106000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"753ecaff7f1cf4f951a67c85fa033d637635a617","modified":1454337098000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"0b9c7097136ac8e4a07d9702fc4dbe0345ac7596","modified":1454336369000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"3ba64c410edd07e7bf5e9900d9ad9d76f2ff5828","modified":1454336369000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1454336369000},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"64037f515aad1386dd2255361eefe3197a5a8e9a","modified":1454336369000},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1454336369000},{"_id":"themes/apollo/.git/objects/pack/pack-b163e92f7706a44e02a5e0b1959ae02c59e61862.pack","hash":"9abc3618485b4bf387d16d1d34ad5f5e737a3b0c","modified":1454336369000},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"64037f515aad1386dd2255361eefe3197a5a8e9a","modified":1454336369000},{"_id":"themes/apollo/source/favicon.jpg","hash":"b8665e37b946543153f94f41e6cbfd97bd30990e","modified":1453700869000},{"_id":"public/atom.xml","hash":"c006827a93d4a9dac491cdb7b2d0ecb167498943","modified":1557459670594},{"_id":"public/sitemap.xml","hash":"674f6143775b5c923b5a925043a60853d30511db","modified":1557459670655},{"_id":"public/2019/05/09/study-plan/index.html","hash":"5a383da4d4734e46086a260ef11dd23ef2dfae8e","modified":1557459670661},{"_id":"public/2016/08/30/dingding-isv-development-tips/index.html","hash":"8bee26ceeed2d7e7204155d778d8b037c4ea0a97","modified":1557459670661},{"_id":"public/2016/02/14/how-to-use-h1-h2-h3/index.html","hash":"162af641c30236746f938903bc0b431c51e7e575","modified":1557459670662},{"_id":"public/archives/index.html","hash":"179fddd217651ac860c84b80dfc19cd30266bd1d","modified":1557459670662},{"_id":"public/archives/2016/index.html","hash":"a2b762b32dd608da258832e0813fb9529c9627dd","modified":1557459670662},{"_id":"public/archives/2016/02/index.html","hash":"7f3279943fd4820a194b69a2b4c2bb36cfee53d9","modified":1557459670662},{"_id":"public/archives/2016/08/index.html","hash":"67c9698036851fed70d57673b7d39330b1900d5b","modified":1557459670662},{"_id":"public/archives/2017/index.html","hash":"5df272232e666e56f9e260b704cc163c9eab7fc0","modified":1557459670662},{"_id":"public/archives/2017/06/index.html","hash":"5df272232e666e56f9e260b704cc163c9eab7fc0","modified":1557459670662},{"_id":"public/archives/2019/index.html","hash":"958a5bd982f8f9c4b9cd27a225e97b269a6a3563","modified":1557459670662},{"_id":"public/archives/2019/05/index.html","hash":"958a5bd982f8f9c4b9cd27a225e97b269a6a3563","modified":1557459670662},{"_id":"public/index.html","hash":"30105a4282e74633571dfd989f85579f78c0d0db","modified":1557459670662},{"_id":"public/tags/express-vue-webpack-node/index.html","hash":"294155093687073d67af415361befa1f019f783c","modified":1557459670662},{"_id":"public/tags/React-Redux/index.html","hash":"5df272232e666e56f9e260b704cc163c9eab7fc0","modified":1557459670662},{"_id":"public/tags/front-end/index.html","hash":"fed5a3b81d1dce60e27f53d1764572d2c1dab904","modified":1557459670663},{"_id":"public/tags/dingtalk-isv/index.html","hash":"67c9698036851fed70d57673b7d39330b1900d5b","modified":1557459670663},{"_id":"public/2017/06/11/5-learned-lessons-of-react-redux/index.html","hash":"ebac09205b7bdc5511f2260f2ebbfd4ff5af45c5","modified":1557459670663},{"_id":"public/2016/02/28/setup-express-vue-boilerplate/index.html","hash":"2ec9d5182431e4a69f4d5769e2c294ba01e32db9","modified":1557459670663},{"_id":"public/2016/02/01/meteor-qiniu-client-upload-example/index.html","hash":"8160ea8e7607eecb4e488522643a2f6aec8d8efb","modified":1557459670663},{"_id":"public/scss/apollo.scss","hash":"2f0ecd6ea1fec0aad4097dcb509b5ed5d1badd5c","modified":1557459670665},{"_id":"public/2016/02/01/meteor-qiniu-client-upload-example/qiniu-upload-flow.png","hash":"717336a978f45881e2c3b7e65dad4740e28712d3","modified":1557459670665},{"_id":"public/css/apollo.css","hash":"3769b55e027697d6d163ddf82b664b16c767ba9c","modified":1557459670669},{"_id":"public/favicon.jpg","hash":"b8665e37b946543153f94f41e6cbfd97bd30990e","modified":1557459670679}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"understand-ssh-port-forwarding","date":"2018-02-24T18:33:07.000Z","_content":"\n以前我对ssh端口转发命令的格式一直没理解，最近看了[一篇博客](https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/)很有启发，琢磨了一下总算是弄明白了。\n\n让我就尝试用最通俗易懂的语言解释给你听什么是ssh端口转发以及如何运用这个命令。\n\n## 回顾ssh连接中的一些概念\n\nssh连接可以双向\n\n假设你有一台笔记本，hostname是laptop，同时你还有一台ISP主机服务器，hostname是isp。\n\n笔记本电脑是“本地”，称ISP主机是“远程”。\n\n当你在笔记本上执行 `ssh root@isp` 成功登陆ISP主机后，一个ssh连接便建立起来了。\n\n这是一条双向的连接，意味着\n\n\n","source":"_drafts/understand-ssh-port-forwarding.md","raw":"title: understand-ssh-port-forwarding\ndate: 2018-02-25 02:33:07\ntags: network shell\n---\n\n以前我对ssh端口转发命令的格式一直没理解，最近看了[一篇博客](https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/)很有启发，琢磨了一下总算是弄明白了。\n\n让我就尝试用最通俗易懂的语言解释给你听什么是ssh端口转发以及如何运用这个命令。\n\n## 回顾ssh连接中的一些概念\n\nssh连接可以双向\n\n假设你有一台笔记本，hostname是laptop，同时你还有一台ISP主机服务器，hostname是isp。\n\n笔记本电脑是“本地”，称ISP主机是“远程”。\n\n当你在笔记本上执行 `ssh root@isp` 成功登陆ISP主机后，一个ssh连接便建立起来了。\n\n这是一条双向的连接，意味着\n\n\n","slug":"understand-ssh-port-forwarding","published":0,"updated":"2019-05-10T02:38:28.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vk10000u9yyjv76t2xm","content":"<p>以前我对ssh端口转发命令的格式一直没理解，最近看了<a href=\"https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/\" target=\"_blank\" rel=\"noopener\">一篇博客</a>很有启发，琢磨了一下总算是弄明白了。</p>\n<p>让我就尝试用最通俗易懂的语言解释给你听什么是ssh端口转发以及如何运用这个命令。</p>\n<h2 id=\"回顾ssh连接中的一些概念\"><a href=\"#回顾ssh连接中的一些概念\" class=\"headerlink\" title=\"回顾ssh连接中的一些概念\"></a>回顾ssh连接中的一些概念</h2><p>ssh连接可以双向</p>\n<p>假设你有一台笔记本，hostname是laptop，同时你还有一台ISP主机服务器，hostname是isp。</p>\n<p>笔记本电脑是“本地”，称ISP主机是“远程”。</p>\n<p>当你在笔记本上执行 <code>ssh root@isp</code> 成功登陆ISP主机后，一个ssh连接便建立起来了。</p>\n<p>这是一条双向的连接，意味着</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前我对ssh端口转发命令的格式一直没理解，最近看了<a href=\"https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/\" target=\"_blank\" rel=\"noopener\">一篇博客</a>很有启发，琢磨了一下总算是弄明白了。</p>\n<p>让我就尝试用最通俗易懂的语言解释给你听什么是ssh端口转发以及如何运用这个命令。</p>\n<h2 id=\"回顾ssh连接中的一些概念\"><a href=\"#回顾ssh连接中的一些概念\" class=\"headerlink\" title=\"回顾ssh连接中的一些概念\"></a>回顾ssh连接中的一些概念</h2><p>ssh连接可以双向</p>\n<p>假设你有一台笔记本，hostname是laptop，同时你还有一台ISP主机服务器，hostname是isp。</p>\n<p>笔记本电脑是“本地”，称ISP主机是“远程”。</p>\n<p>当你在笔记本上执行 <code>ssh root@isp</code> 成功登陆ISP主机后，一个ssh连接便建立起来了。</p>\n<p>这是一条双向的连接，意味着</p>\n"},{"title":"从零开始搭建 Express + Vue 生产环境","_content":"\n上一篇文章介绍了如何从零开始搭建 Express + Vue 的开发环境，现在介绍一下如何搭建生产环境。\n\n## 前端：压缩、混淆、分离css\n\n与开发环境相比，部署在生产环境中的代码需要经过压缩，去除注释、去除多余的空格换行，去除 source map，等等。可别小看了压缩代码这个步骤，也许 webpack 在开发环境中打包产生的代码超过了 10Mb，但经过压缩以后只有不到 1Mb。需要注意的是，不光是 javascript，像是 html，css 也都可以压缩。\n\n另一个比较重要的步骤是代码混淆，这是前端特有的步骤。因为前端的 javascript、html、css 是完全暴露给用户的，基本没有安全性可言。经过代码混淆以后，可以很有效地增加破解前端的困难，杜绝大部分不怀好意的企图。\n\n最后是分离css文件。在开发的时候，我们是将所有资源文件都打包成一个 js 文件一并加载的，这样便于开发调试（hot-reload）。但是在生产环境中，我们需要将其分离成单独的文件。这是因为 css 文件普遍没有 javascript 文件巨大，但是却控制了整个页面的外表，对用户体验至关重要，如果合并在 js 代码中会导致页面加载速度慢。所以应该单独分离出去放在 html 文档顶部让浏览器优先加载。\n\n## 后端：ES5转码，编译依赖模块，分离配置\n\nNode 的运行环境仍然是基于 ES5 的，在开发环境中，为了便于调试我们采用的是 babel 动态转码的方式（require register）。但是在生产环境中，仍然推荐先把 ES6 代码转码成 ES5 再运行。好处就是在 production server 上不需要再安装 babel 了，你肯定不想折腾 production server 上的 babel 版本。所以，首先我们要使用 babel 工具将所有源文件编译成 ES5 语法。\n\n编译依赖模块，这个比较好理解，就是将 node_modules 中用到的依赖都按照 production 模式编译一下，主要是可以降低依赖模块的文件体积，便于部署到服务器上，有些模块甚至还会在性能上有些提升。\n\n整理各种配置项，比如数据库名、用户名、端口等等，并将他们按照开发环境和生产环境分离开，做到让程序根据 NODE_ENV 去加载正确的配置。另外，建议将配置项以环境变量的形式引入，而不是保存在文件里。这主要是出于安全考虑，因为把密码、端口这些敏感信息明文保存在文件中实在不是一件明智的举动。\n\n最后，后端没有必要混淆代码。\n","source":"_drafts/setup-express-vue-production.md","raw":"title: 从零开始搭建 Express + Vue 生产环境\ntags: express, vue, webpack, node\n---\n\n上一篇文章介绍了如何从零开始搭建 Express + Vue 的开发环境，现在介绍一下如何搭建生产环境。\n\n## 前端：压缩、混淆、分离css\n\n与开发环境相比，部署在生产环境中的代码需要经过压缩，去除注释、去除多余的空格换行，去除 source map，等等。可别小看了压缩代码这个步骤，也许 webpack 在开发环境中打包产生的代码超过了 10Mb，但经过压缩以后只有不到 1Mb。需要注意的是，不光是 javascript，像是 html，css 也都可以压缩。\n\n另一个比较重要的步骤是代码混淆，这是前端特有的步骤。因为前端的 javascript、html、css 是完全暴露给用户的，基本没有安全性可言。经过代码混淆以后，可以很有效地增加破解前端的困难，杜绝大部分不怀好意的企图。\n\n最后是分离css文件。在开发的时候，我们是将所有资源文件都打包成一个 js 文件一并加载的，这样便于开发调试（hot-reload）。但是在生产环境中，我们需要将其分离成单独的文件。这是因为 css 文件普遍没有 javascript 文件巨大，但是却控制了整个页面的外表，对用户体验至关重要，如果合并在 js 代码中会导致页面加载速度慢。所以应该单独分离出去放在 html 文档顶部让浏览器优先加载。\n\n## 后端：ES5转码，编译依赖模块，分离配置\n\nNode 的运行环境仍然是基于 ES5 的，在开发环境中，为了便于调试我们采用的是 babel 动态转码的方式（require register）。但是在生产环境中，仍然推荐先把 ES6 代码转码成 ES5 再运行。好处就是在 production server 上不需要再安装 babel 了，你肯定不想折腾 production server 上的 babel 版本。所以，首先我们要使用 babel 工具将所有源文件编译成 ES5 语法。\n\n编译依赖模块，这个比较好理解，就是将 node_modules 中用到的依赖都按照 production 模式编译一下，主要是可以降低依赖模块的文件体积，便于部署到服务器上，有些模块甚至还会在性能上有些提升。\n\n整理各种配置项，比如数据库名、用户名、端口等等，并将他们按照开发环境和生产环境分离开，做到让程序根据 NODE_ENV 去加载正确的配置。另外，建议将配置项以环境变量的形式引入，而不是保存在文件里。这主要是出于安全考虑，因为把密码、端口这些敏感信息明文保存在文件中实在不是一件明智的举动。\n\n最后，后端没有必要混淆代码。\n","slug":"setup-express-vue-production","published":0,"date":"2016-03-27T15:30:41.000Z","updated":"2016-03-27T15:31:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkc0003u9yyq15m0ejt","content":"<p>上一篇文章介绍了如何从零开始搭建 Express + Vue 的开发环境，现在介绍一下如何搭建生产环境。</p>\n<h2 id=\"前端：压缩、混淆、分离css\"><a href=\"#前端：压缩、混淆、分离css\" class=\"headerlink\" title=\"前端：压缩、混淆、分离css\"></a>前端：压缩、混淆、分离css</h2><p>与开发环境相比，部署在生产环境中的代码需要经过压缩，去除注释、去除多余的空格换行，去除 source map，等等。可别小看了压缩代码这个步骤，也许 webpack 在开发环境中打包产生的代码超过了 10Mb，但经过压缩以后只有不到 1Mb。需要注意的是，不光是 javascript，像是 html，css 也都可以压缩。</p>\n<p>另一个比较重要的步骤是代码混淆，这是前端特有的步骤。因为前端的 javascript、html、css 是完全暴露给用户的，基本没有安全性可言。经过代码混淆以后，可以很有效地增加破解前端的困难，杜绝大部分不怀好意的企图。</p>\n<p>最后是分离css文件。在开发的时候，我们是将所有资源文件都打包成一个 js 文件一并加载的，这样便于开发调试（hot-reload）。但是在生产环境中，我们需要将其分离成单独的文件。这是因为 css 文件普遍没有 javascript 文件巨大，但是却控制了整个页面的外表，对用户体验至关重要，如果合并在 js 代码中会导致页面加载速度慢。所以应该单独分离出去放在 html 文档顶部让浏览器优先加载。</p>\n<h2 id=\"后端：ES5转码，编译依赖模块，分离配置\"><a href=\"#后端：ES5转码，编译依赖模块，分离配置\" class=\"headerlink\" title=\"后端：ES5转码，编译依赖模块，分离配置\"></a>后端：ES5转码，编译依赖模块，分离配置</h2><p>Node 的运行环境仍然是基于 ES5 的，在开发环境中，为了便于调试我们采用的是 babel 动态转码的方式（require register）。但是在生产环境中，仍然推荐先把 ES6 代码转码成 ES5 再运行。好处就是在 production server 上不需要再安装 babel 了，你肯定不想折腾 production server 上的 babel 版本。所以，首先我们要使用 babel 工具将所有源文件编译成 ES5 语法。</p>\n<p>编译依赖模块，这个比较好理解，就是将 node_modules 中用到的依赖都按照 production 模式编译一下，主要是可以降低依赖模块的文件体积，便于部署到服务器上，有些模块甚至还会在性能上有些提升。</p>\n<p>整理各种配置项，比如数据库名、用户名、端口等等，并将他们按照开发环境和生产环境分离开，做到让程序根据 NODE_ENV 去加载正确的配置。另外，建议将配置项以环境变量的形式引入，而不是保存在文件里。这主要是出于安全考虑，因为把密码、端口这些敏感信息明文保存在文件中实在不是一件明智的举动。</p>\n<p>最后，后端没有必要混淆代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一篇文章介绍了如何从零开始搭建 Express + Vue 的开发环境，现在介绍一下如何搭建生产环境。</p>\n<h2 id=\"前端：压缩、混淆、分离css\"><a href=\"#前端：压缩、混淆、分离css\" class=\"headerlink\" title=\"前端：压缩、混淆、分离css\"></a>前端：压缩、混淆、分离css</h2><p>与开发环境相比，部署在生产环境中的代码需要经过压缩，去除注释、去除多余的空格换行，去除 source map，等等。可别小看了压缩代码这个步骤，也许 webpack 在开发环境中打包产生的代码超过了 10Mb，但经过压缩以后只有不到 1Mb。需要注意的是，不光是 javascript，像是 html，css 也都可以压缩。</p>\n<p>另一个比较重要的步骤是代码混淆，这是前端特有的步骤。因为前端的 javascript、html、css 是完全暴露给用户的，基本没有安全性可言。经过代码混淆以后，可以很有效地增加破解前端的困难，杜绝大部分不怀好意的企图。</p>\n<p>最后是分离css文件。在开发的时候，我们是将所有资源文件都打包成一个 js 文件一并加载的，这样便于开发调试（hot-reload）。但是在生产环境中，我们需要将其分离成单独的文件。这是因为 css 文件普遍没有 javascript 文件巨大，但是却控制了整个页面的外表，对用户体验至关重要，如果合并在 js 代码中会导致页面加载速度慢。所以应该单独分离出去放在 html 文档顶部让浏览器优先加载。</p>\n<h2 id=\"后端：ES5转码，编译依赖模块，分离配置\"><a href=\"#后端：ES5转码，编译依赖模块，分离配置\" class=\"headerlink\" title=\"后端：ES5转码，编译依赖模块，分离配置\"></a>后端：ES5转码，编译依赖模块，分离配置</h2><p>Node 的运行环境仍然是基于 ES5 的，在开发环境中，为了便于调试我们采用的是 babel 动态转码的方式（require register）。但是在生产环境中，仍然推荐先把 ES6 代码转码成 ES5 再运行。好处就是在 production server 上不需要再安装 babel 了，你肯定不想折腾 production server 上的 babel 版本。所以，首先我们要使用 babel 工具将所有源文件编译成 ES5 语法。</p>\n<p>编译依赖模块，这个比较好理解，就是将 node_modules 中用到的依赖都按照 production 模式编译一下，主要是可以降低依赖模块的文件体积，便于部署到服务器上，有些模块甚至还会在性能上有些提升。</p>\n<p>整理各种配置项，比如数据库名、用户名、端口等等，并将他们按照开发环境和生产环境分离开，做到让程序根据 NODE_ENV 去加载正确的配置。另外，建议将配置项以环境变量的形式引入，而不是保存在文件里。这主要是出于安全考虑，因为把密码、端口这些敏感信息明文保存在文件中实在不是一件明智的举动。</p>\n<p>最后，后端没有必要混淆代码。</p>\n"},{"title":"5个有关react-redux的心得","date":"2017-06-11T01:07:28.000Z","_content":"\n## Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关\n\naction 应该尽可能细粒度，做小的、与业务无关的事情；在action creator中对action进行组合，复用。\n\n举个例子，假设你需要一个更新用户名的 API，可以写成这样：\n\n```javascript\n// action.js\nfunction updateUserName(userId, name) {\n  return (dispatch) => {\n    request.put('/api/user-name/' + userId)\n    .then((user) => dispatch({\n      type: UPDATE_ONE_USER,\n      payload: { user },\n    }));\n  };\n}\n\n/////////////\n\n// reducer.js\nfunction user(state, action) {\n  switch (action.type) {\n    case UPDATE_ONE_USER: return { ...state, user: action.payload.user };\n  }\n}\n```\n\n这样，假如未来需要新增其他更新用户信息的API（比如变更权限），那么所要做的只是新增一个action creator，复用以前的action type即可。例如：\n\n```javascript\n// action.js\nfunction updateUserPermission(userId, permission) {\n  return (dispatch) => {\n    request.put('/api/user-permission/' + userId)\n    .then((user) => dispatch({\n      type: UPDATE_ONE_USER,\n      payload: { user },\n    }));\n  };\n}\n```\n\n## 非共享的、局部的、UI only的状态，不一定非要放在redux state中\n\n最典型的例子是loading状态。每个API都有独立的loading状态，甚至同一个API的每次调用都是独立的loading状态。在redux中记录这些loading信息是一件挺吃力不讨好的事情。因为首先正确记录loading状态就不是个容易的事情，很可能必须得用`API名字 + 参数`为key来记录，在使用的时候也必须小心地使用`API名字 + 参数`去拿到这个值。其次，这些loading状态可能只是一个component需要的局部UI状态，当API请求结束，loading状态的使命也宣告结束，没有存在的必要了，也就不应该存在redux里。\n\n遇到这种问题，建议把loading放在Component内部的state中，用callback触发setState，例如：\n\n```javascript\n// action.js\nfunction updateUserName(userId, name, callback = () => {}) { // 注意多了一个callback参数\n  return (dispatch) => {\n    request.put('/api/user-name/' + userId)\n    .then((user) => {\n      callback();\n      dispatch({\n        type: UPDATE_ONE_USER,\n        payload: { user },\n      });\n    })\n    .catch((err) => callback(err));\n  };\n}\n\n///////////\n\n// 具体在用的时候结合this.setState\nclass MyComponent extends React.Component {\n  updateUserName(userId, name) {\n    this.setState({ isUpdating: true }); // <-- loading开始\n    this.props.updateUserName(userId, name, (err) => { // 通过callback调用setState\n      this.setState({ isUpdating: false }); // <-- loading结束\n    });\n  }\n  ...\n}\n```\n\n## entities足以，idList慎用\n\nentities指的是一种map数据结构，内容为 id -> data。例如：\n\n```javascript\nuserEntities = {\n  [user1.id]: user1,\n  [user2.id]: user2,\n  ...\n};\n\njobEntities = {\n  [job1.id]: job1,\n  [job2.id]: job2,\n  ...\n}\n```\n\n对于列表数据，一种常见的做法是用entities存储数据，然后用idList来表示顺序。比如：\n\n```javascript\nuserEntities = {\n  1: user1,\n  2: user2,\n  3: user3,\n}\n\nascIdList = [1, 2, 3]; // 顺序排列\ndescIdList = [3, 2, 1]; // 逆序排列\nmyIdList = [2, 3, 1]; // 其他特殊的排列顺序\n\n// render的时候只要按照idList进行map即可：\nascUsers = ascIdList.map((id) => userEntities[id]);\ndescUsers = descIdList.map((id) => userEntities[id]);\nmyUsers = myIdList.map((id) => userEntities[id]);\n```\n\n这种组织state的方式有一个最大的问题，那就是当涉及到数据变化的时候，所有相关的idList也需要改动，不然就会发生问题。比如删掉了id是2的user，那么三个idList都要做一遍filter，去掉2。\n\n为了避免这种数据改动导致idList被牵连改动的问题，另一种做法是完全不用idList，而是在使用的地方就地排序。比如：\n\n```javascript\nuserEntities = {\n  1: user1，\n  2: user2,\n  3: user3,\n};\n\n// 没有idList，用到的时候现场排序\nascUser = Object.keys(userEntities).sort(ascCompare).map((id) => userEntities[id]);\ndescUser = Object.keys(userEntities.sort(descCompare).map((id) => userEntities[id]);\nmyUser = Object.keys(userEntities.sort(myCompare).map((id) => userEntities[id]);\n```\n\n不过呢，上面这个做法虽然避免了idList的牵连改动，但每次使用的时候都要sort，性能上有一定影响。没关系，这个可以用memoized function解决。比如使用reselect。\n\n所以，大部分时候用entities就够了，引入idList可能会更麻烦\n\n## 只要你愿意，什么组件都可以connect到redux store\n\nredux 作者推荐的一种使用redux的方式是将connect用作container组件，将具体的render逻辑放在presentation组件中。这样，data source和data presentation就可以解耦，便于替换和复用。\n\n理论上，只要你愿意，任何组件只要connect到redux store，就可以做container组件。然而很多人认为选择哪些组件做container是十分有讲究的。有些人认为只有顶层组件才是container组件，例如APP组件；有些人认为router组件算是container组件。哪一种是对的呢？\n\n回到问题的根本，为什么我们要求不是所有组件都可以connect呢？主要原因还是便于测试，进而提高代码可靠性。当然也有一些性能上的考虑，但在大多数情况下，性能都不是主要考虑的问题。\n\n所以，限制只有某些组件才能做container的做法，初衷是为了保证代码单元测试起来更加容易。这其实不是一个很强力的观点，因为99%前端工程都没有单元测试，强行用这种观点去实践，反而会给开发带来额外的麻烦。\n\n也许你见过这样的代码：\n\n```javascript\n// 这是 container 组件\nclass ContainerComponent extends React.Component {\n  render() {\n    return (\n      <MiddleComponent\n        a={this.props.a}\n        b={this.props.b}\n        c={this.props.c}\n        d={this.props.d}\n      />\n    );\n  }\n}\n\nclass MiddleComponent extends React.Component {\n  render() {\n    return (\n      <InnerComponent\n        a={this.props.a} // <-- a、b、c、d这些属性对MiddleComponent完全没有意义，只是原封不动地传给了InnerComponent\n        b={this.props.b}\n        c={this.props.c}\n        d={this.props.d}\n      />\n    );\n  }\n}\n```\n\n看到这种代码，我立刻就想到了“酒肉穿肠过，佛祖心中留”。借用王银曾经评论haskell的比喻，这就好比是一个没有无线电的世界，所有的信号传递都只能通过一根根电线链接两头。\n\n为了避免上面那种壮丽的景象，有人选择这么写：\n\n```javascript\nclass MiddleComponent extends React.Component {\n  render() {\n    return (\n      <InnerComponent {...this.props}/>\n    );\n  }\n}\n```\n\n这种写法看似简单了很多，但由于props的传递是隐式的，开发者要弄清究竟传了什么，就必须回溯到最开始的container组件。这就好比一些数学教材中的证明答案：由第xx题的证明结论，可以得到blablabla。但是你去看第XX题，发现也是一样的：由第YY题的证明结论可以得到blablabla。然后你又要去看YY题的证明过程，可能得到的还是类似的东西。。\n\n再多说一句，凡是隐式的、动态的写法，基本都是有害的。因为写的时候你爽了，以后其他人维护代码的时候就会被坑惨了。\n\n所以，不要迷信什么必须只有顶层容器才能connect之类的best practice，大胆connect吧，只要别再common组件里connect就行（common组件不要混入业务逻辑，也就不要connect）。\n\n## 避免嵌套过深的state结构\n\n这个道理很容易理解，越是嵌套深，越是不容易修改（因为要return新的state），不懂的话吃过亏也就懂了。\n","source":"_posts/5-learned-lessons-of-react-redux.md","raw":"title: 5个有关react-redux的心得\ndate: 2017-06-11 09:07:28\ntags: React, Redux\n---\n\n## Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关\n\naction 应该尽可能细粒度，做小的、与业务无关的事情；在action creator中对action进行组合，复用。\n\n举个例子，假设你需要一个更新用户名的 API，可以写成这样：\n\n```javascript\n// action.js\nfunction updateUserName(userId, name) {\n  return (dispatch) => {\n    request.put('/api/user-name/' + userId)\n    .then((user) => dispatch({\n      type: UPDATE_ONE_USER,\n      payload: { user },\n    }));\n  };\n}\n\n/////////////\n\n// reducer.js\nfunction user(state, action) {\n  switch (action.type) {\n    case UPDATE_ONE_USER: return { ...state, user: action.payload.user };\n  }\n}\n```\n\n这样，假如未来需要新增其他更新用户信息的API（比如变更权限），那么所要做的只是新增一个action creator，复用以前的action type即可。例如：\n\n```javascript\n// action.js\nfunction updateUserPermission(userId, permission) {\n  return (dispatch) => {\n    request.put('/api/user-permission/' + userId)\n    .then((user) => dispatch({\n      type: UPDATE_ONE_USER,\n      payload: { user },\n    }));\n  };\n}\n```\n\n## 非共享的、局部的、UI only的状态，不一定非要放在redux state中\n\n最典型的例子是loading状态。每个API都有独立的loading状态，甚至同一个API的每次调用都是独立的loading状态。在redux中记录这些loading信息是一件挺吃力不讨好的事情。因为首先正确记录loading状态就不是个容易的事情，很可能必须得用`API名字 + 参数`为key来记录，在使用的时候也必须小心地使用`API名字 + 参数`去拿到这个值。其次，这些loading状态可能只是一个component需要的局部UI状态，当API请求结束，loading状态的使命也宣告结束，没有存在的必要了，也就不应该存在redux里。\n\n遇到这种问题，建议把loading放在Component内部的state中，用callback触发setState，例如：\n\n```javascript\n// action.js\nfunction updateUserName(userId, name, callback = () => {}) { // 注意多了一个callback参数\n  return (dispatch) => {\n    request.put('/api/user-name/' + userId)\n    .then((user) => {\n      callback();\n      dispatch({\n        type: UPDATE_ONE_USER,\n        payload: { user },\n      });\n    })\n    .catch((err) => callback(err));\n  };\n}\n\n///////////\n\n// 具体在用的时候结合this.setState\nclass MyComponent extends React.Component {\n  updateUserName(userId, name) {\n    this.setState({ isUpdating: true }); // <-- loading开始\n    this.props.updateUserName(userId, name, (err) => { // 通过callback调用setState\n      this.setState({ isUpdating: false }); // <-- loading结束\n    });\n  }\n  ...\n}\n```\n\n## entities足以，idList慎用\n\nentities指的是一种map数据结构，内容为 id -> data。例如：\n\n```javascript\nuserEntities = {\n  [user1.id]: user1,\n  [user2.id]: user2,\n  ...\n};\n\njobEntities = {\n  [job1.id]: job1,\n  [job2.id]: job2,\n  ...\n}\n```\n\n对于列表数据，一种常见的做法是用entities存储数据，然后用idList来表示顺序。比如：\n\n```javascript\nuserEntities = {\n  1: user1,\n  2: user2,\n  3: user3,\n}\n\nascIdList = [1, 2, 3]; // 顺序排列\ndescIdList = [3, 2, 1]; // 逆序排列\nmyIdList = [2, 3, 1]; // 其他特殊的排列顺序\n\n// render的时候只要按照idList进行map即可：\nascUsers = ascIdList.map((id) => userEntities[id]);\ndescUsers = descIdList.map((id) => userEntities[id]);\nmyUsers = myIdList.map((id) => userEntities[id]);\n```\n\n这种组织state的方式有一个最大的问题，那就是当涉及到数据变化的时候，所有相关的idList也需要改动，不然就会发生问题。比如删掉了id是2的user，那么三个idList都要做一遍filter，去掉2。\n\n为了避免这种数据改动导致idList被牵连改动的问题，另一种做法是完全不用idList，而是在使用的地方就地排序。比如：\n\n```javascript\nuserEntities = {\n  1: user1，\n  2: user2,\n  3: user3,\n};\n\n// 没有idList，用到的时候现场排序\nascUser = Object.keys(userEntities).sort(ascCompare).map((id) => userEntities[id]);\ndescUser = Object.keys(userEntities.sort(descCompare).map((id) => userEntities[id]);\nmyUser = Object.keys(userEntities.sort(myCompare).map((id) => userEntities[id]);\n```\n\n不过呢，上面这个做法虽然避免了idList的牵连改动，但每次使用的时候都要sort，性能上有一定影响。没关系，这个可以用memoized function解决。比如使用reselect。\n\n所以，大部分时候用entities就够了，引入idList可能会更麻烦\n\n## 只要你愿意，什么组件都可以connect到redux store\n\nredux 作者推荐的一种使用redux的方式是将connect用作container组件，将具体的render逻辑放在presentation组件中。这样，data source和data presentation就可以解耦，便于替换和复用。\n\n理论上，只要你愿意，任何组件只要connect到redux store，就可以做container组件。然而很多人认为选择哪些组件做container是十分有讲究的。有些人认为只有顶层组件才是container组件，例如APP组件；有些人认为router组件算是container组件。哪一种是对的呢？\n\n回到问题的根本，为什么我们要求不是所有组件都可以connect呢？主要原因还是便于测试，进而提高代码可靠性。当然也有一些性能上的考虑，但在大多数情况下，性能都不是主要考虑的问题。\n\n所以，限制只有某些组件才能做container的做法，初衷是为了保证代码单元测试起来更加容易。这其实不是一个很强力的观点，因为99%前端工程都没有单元测试，强行用这种观点去实践，反而会给开发带来额外的麻烦。\n\n也许你见过这样的代码：\n\n```javascript\n// 这是 container 组件\nclass ContainerComponent extends React.Component {\n  render() {\n    return (\n      <MiddleComponent\n        a={this.props.a}\n        b={this.props.b}\n        c={this.props.c}\n        d={this.props.d}\n      />\n    );\n  }\n}\n\nclass MiddleComponent extends React.Component {\n  render() {\n    return (\n      <InnerComponent\n        a={this.props.a} // <-- a、b、c、d这些属性对MiddleComponent完全没有意义，只是原封不动地传给了InnerComponent\n        b={this.props.b}\n        c={this.props.c}\n        d={this.props.d}\n      />\n    );\n  }\n}\n```\n\n看到这种代码，我立刻就想到了“酒肉穿肠过，佛祖心中留”。借用王银曾经评论haskell的比喻，这就好比是一个没有无线电的世界，所有的信号传递都只能通过一根根电线链接两头。\n\n为了避免上面那种壮丽的景象，有人选择这么写：\n\n```javascript\nclass MiddleComponent extends React.Component {\n  render() {\n    return (\n      <InnerComponent {...this.props}/>\n    );\n  }\n}\n```\n\n这种写法看似简单了很多，但由于props的传递是隐式的，开发者要弄清究竟传了什么，就必须回溯到最开始的container组件。这就好比一些数学教材中的证明答案：由第xx题的证明结论，可以得到blablabla。但是你去看第XX题，发现也是一样的：由第YY题的证明结论可以得到blablabla。然后你又要去看YY题的证明过程，可能得到的还是类似的东西。。\n\n再多说一句，凡是隐式的、动态的写法，基本都是有害的。因为写的时候你爽了，以后其他人维护代码的时候就会被坑惨了。\n\n所以，不要迷信什么必须只有顶层容器才能connect之类的best practice，大胆connect吧，只要别再common组件里connect就行（common组件不要混入业务逻辑，也就不要connect）。\n\n## 避免嵌套过深的state结构\n\n这个道理很容易理解，越是嵌套深，越是不容易修改（因为要return新的state），不懂的话吃过亏也就懂了。\n","slug":"5-learned-lessons-of-react-redux","published":1,"updated":"2017-06-11T03:10:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkd0004u9yylsrtwsqm","content":"<h2 id=\"Action-Type-尽量保持与业务逻辑无关，Action-Creator-可以与业务逻辑有关\"><a href=\"#Action-Type-尽量保持与业务逻辑无关，Action-Creator-可以与业务逻辑有关\" class=\"headerlink\" title=\"Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关\"></a>Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关</h2><p>action 应该尽可能细粒度，做小的、与业务无关的事情；在action creator中对action进行组合，复用。</p>\n<p>举个例子，假设你需要一个更新用户名的 API，可以写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateUserName</span>(<span class=\"params\">userId, name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    request.put(<span class=\"string\">'/api/user-name/'</span> + userId)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> dispatch(&#123;</span><br><span class=\"line\">      type: UPDATE_ONE_USER,</span><br><span class=\"line\">      payload: &#123; user &#125;,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reducer.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">user</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> UPDATE_ONE_USER: <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">user</span>: action.payload.user &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，假如未来需要新增其他更新用户信息的API（比如变更权限），那么所要做的只是新增一个action creator，复用以前的action type即可。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateUserPermission</span>(<span class=\"params\">userId, permission</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    request.put(<span class=\"string\">'/api/user-permission/'</span> + userId)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> dispatch(&#123;</span><br><span class=\"line\">      type: UPDATE_ONE_USER,</span><br><span class=\"line\">      payload: &#123; user &#125;,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非共享的、局部的、UI-only的状态，不一定非要放在redux-state中\"><a href=\"#非共享的、局部的、UI-only的状态，不一定非要放在redux-state中\" class=\"headerlink\" title=\"非共享的、局部的、UI only的状态，不一定非要放在redux state中\"></a>非共享的、局部的、UI only的状态，不一定非要放在redux state中</h2><p>最典型的例子是loading状态。每个API都有独立的loading状态，甚至同一个API的每次调用都是独立的loading状态。在redux中记录这些loading信息是一件挺吃力不讨好的事情。因为首先正确记录loading状态就不是个容易的事情，很可能必须得用<code>API名字 + 参数</code>为key来记录，在使用的时候也必须小心地使用<code>API名字 + 参数</code>去拿到这个值。其次，这些loading状态可能只是一个component需要的局部UI状态，当API请求结束，loading状态的使命也宣告结束，没有存在的必要了，也就不应该存在redux里。</p>\n<p>遇到这种问题，建议把loading放在Component内部的state中，用callback触发setState，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateUserName</span>(<span class=\"params\">userId, name, callback = (</span>) =&gt; </span>&#123;&#125;) &#123; <span class=\"comment\">// 注意多了一个callback参数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    request.put(<span class=\"string\">'/api/user-name/'</span> + userId)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: UPDATE_ONE_USER,</span><br><span class=\"line\">        payload: &#123; user &#125;,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> callback(err));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///////////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体在用的时候结合this.setState</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  updateUserName(userId, name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">isUpdating</span>: <span class=\"literal\">true</span> &#125;); <span class=\"comment\">// &lt;-- loading开始</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.updateUserName(userId, name, (err) =&gt; &#123; <span class=\"comment\">// 通过callback调用setState</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">isUpdating</span>: <span class=\"literal\">false</span> &#125;); <span class=\"comment\">// &lt;-- loading结束</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"entities足以，idList慎用\"><a href=\"#entities足以，idList慎用\" class=\"headerlink\" title=\"entities足以，idList慎用\"></a>entities足以，idList慎用</h2><p>entities指的是一种map数据结构，内容为 id -&gt; data。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userEntities = &#123;</span><br><span class=\"line\">  [user1.id]: user1,</span><br><span class=\"line\">  [user2.id]: user2,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">jobEntities = &#123;</span><br><span class=\"line\">  [job1.id]: job1,</span><br><span class=\"line\">  [job2.id]: job2,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于列表数据，一种常见的做法是用entities存储数据，然后用idList来表示顺序。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userEntities = &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: user1,</span><br><span class=\"line\">  <span class=\"number\">2</span>: user2,</span><br><span class=\"line\">  <span class=\"number\">3</span>: user3,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ascIdList = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]; <span class=\"comment\">// 顺序排列</span></span><br><span class=\"line\">descIdList = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// 逆序排列</span></span><br><span class=\"line\">myIdList = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// 其他特殊的排列顺序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// render的时候只要按照idList进行map即可：</span></span><br><span class=\"line\">ascUsers = ascIdList.map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">descUsers = descIdList.map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">myUsers = myIdList.map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br></pre></td></tr></table></figure>\n<p>这种组织state的方式有一个最大的问题，那就是当涉及到数据变化的时候，所有相关的idList也需要改动，不然就会发生问题。比如删掉了id是2的user，那么三个idList都要做一遍filter，去掉2。</p>\n<p>为了避免这种数据改动导致idList被牵连改动的问题，另一种做法是完全不用idList，而是在使用的地方就地排序。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userEntities = &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: user1，</span><br><span class=\"line\">  <span class=\"number\">2</span>: user2,</span><br><span class=\"line\">  <span class=\"number\">3</span>: user3,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有idList，用到的时候现场排序</span></span><br><span class=\"line\">ascUser = <span class=\"built_in\">Object</span>.keys(userEntities).sort(ascCompare).map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">descUser = <span class=\"built_in\">Object</span>.keys(userEntities.sort(descCompare).map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">myUser = <span class=\"built_in\">Object</span>.keys(userEntities.sort(myCompare).map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br></pre></td></tr></table></figure>\n<p>不过呢，上面这个做法虽然避免了idList的牵连改动，但每次使用的时候都要sort，性能上有一定影响。没关系，这个可以用memoized function解决。比如使用reselect。</p>\n<p>所以，大部分时候用entities就够了，引入idList可能会更麻烦</p>\n<h2 id=\"只要你愿意，什么组件都可以connect到redux-store\"><a href=\"#只要你愿意，什么组件都可以connect到redux-store\" class=\"headerlink\" title=\"只要你愿意，什么组件都可以connect到redux store\"></a>只要你愿意，什么组件都可以connect到redux store</h2><p>redux 作者推荐的一种使用redux的方式是将connect用作container组件，将具体的render逻辑放在presentation组件中。这样，data source和data presentation就可以解耦，便于替换和复用。</p>\n<p>理论上，只要你愿意，任何组件只要connect到redux store，就可以做container组件。然而很多人认为选择哪些组件做container是十分有讲究的。有些人认为只有顶层组件才是container组件，例如APP组件；有些人认为router组件算是container组件。哪一种是对的呢？</p>\n<p>回到问题的根本，为什么我们要求不是所有组件都可以connect呢？主要原因还是便于测试，进而提高代码可靠性。当然也有一些性能上的考虑，但在大多数情况下，性能都不是主要考虑的问题。</p>\n<p>所以，限制只有某些组件才能做container的做法，初衷是为了保证代码单元测试起来更加容易。这其实不是一个很强力的观点，因为99%前端工程都没有单元测试，强行用这种观点去实践，反而会给开发带来额外的麻烦。</p>\n<p>也许你见过这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是 container 组件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContainerComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;MiddleComponent</span><br><span class=\"line\">        a=&#123;<span class=\"keyword\">this</span>.props.a&#125;</span><br><span class=\"line\">        b=&#123;<span class=\"keyword\">this</span>.props.b&#125;</span><br><span class=\"line\">        c=&#123;<span class=\"keyword\">this</span>.props.c&#125;</span><br><span class=\"line\">        d=&#123;<span class=\"keyword\">this</span>.props.d&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MiddleComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;InnerComponent</span><br><span class=\"line\">        a=&#123;<span class=\"keyword\">this</span>.props.a&#125; <span class=\"comment\">// &lt;-- a、b、c、d这些属性对MiddleComponent完全没有意义，只是原封不动地传给了InnerComponent</span></span><br><span class=\"line\">        b=&#123;<span class=\"keyword\">this</span>.props.b&#125;</span><br><span class=\"line\">        c=&#123;<span class=\"keyword\">this</span>.props.c&#125;</span><br><span class=\"line\">        d=&#123;<span class=\"keyword\">this</span>.props.d&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这种代码，我立刻就想到了“酒肉穿肠过，佛祖心中留”。借用王银曾经评论haskell的比喻，这就好比是一个没有无线电的世界，所有的信号传递都只能通过一根根电线链接两头。</p>\n<p>为了避免上面那种壮丽的景象，有人选择这么写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MiddleComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;InnerComponent &#123;...this.props&#125;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种写法看似简单了很多，但由于props的传递是隐式的，开发者要弄清究竟传了什么，就必须回溯到最开始的container组件。这就好比一些数学教材中的证明答案：由第xx题的证明结论，可以得到blablabla。但是你去看第XX题，发现也是一样的：由第YY题的证明结论可以得到blablabla。然后你又要去看YY题的证明过程，可能得到的还是类似的东西。。</p>\n<p>再多说一句，凡是隐式的、动态的写法，基本都是有害的。因为写的时候你爽了，以后其他人维护代码的时候就会被坑惨了。</p>\n<p>所以，不要迷信什么必须只有顶层容器才能connect之类的best practice，大胆connect吧，只要别再common组件里connect就行（common组件不要混入业务逻辑，也就不要connect）。</p>\n<h2 id=\"避免嵌套过深的state结构\"><a href=\"#避免嵌套过深的state结构\" class=\"headerlink\" title=\"避免嵌套过深的state结构\"></a>避免嵌套过深的state结构</h2><p>这个道理很容易理解，越是嵌套深，越是不容易修改（因为要return新的state），不懂的话吃过亏也就懂了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Action-Type-尽量保持与业务逻辑无关，Action-Creator-可以与业务逻辑有关\"><a href=\"#Action-Type-尽量保持与业务逻辑无关，Action-Creator-可以与业务逻辑有关\" class=\"headerlink\" title=\"Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关\"></a>Action Type 尽量保持与业务逻辑无关，Action Creator 可以与业务逻辑有关</h2><p>action 应该尽可能细粒度，做小的、与业务无关的事情；在action creator中对action进行组合，复用。</p>\n<p>举个例子，假设你需要一个更新用户名的 API，可以写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateUserName</span>(<span class=\"params\">userId, name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    request.put(<span class=\"string\">'/api/user-name/'</span> + userId)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> dispatch(&#123;</span><br><span class=\"line\">      type: UPDATE_ONE_USER,</span><br><span class=\"line\">      payload: &#123; user &#125;,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reducer.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">user</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> UPDATE_ONE_USER: <span class=\"keyword\">return</span> &#123; ...state, <span class=\"attr\">user</span>: action.payload.user &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，假如未来需要新增其他更新用户信息的API（比如变更权限），那么所要做的只是新增一个action creator，复用以前的action type即可。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateUserPermission</span>(<span class=\"params\">userId, permission</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    request.put(<span class=\"string\">'/api/user-permission/'</span> + userId)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> dispatch(&#123;</span><br><span class=\"line\">      type: UPDATE_ONE_USER,</span><br><span class=\"line\">      payload: &#123; user &#125;,</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"非共享的、局部的、UI-only的状态，不一定非要放在redux-state中\"><a href=\"#非共享的、局部的、UI-only的状态，不一定非要放在redux-state中\" class=\"headerlink\" title=\"非共享的、局部的、UI only的状态，不一定非要放在redux state中\"></a>非共享的、局部的、UI only的状态，不一定非要放在redux state中</h2><p>最典型的例子是loading状态。每个API都有独立的loading状态，甚至同一个API的每次调用都是独立的loading状态。在redux中记录这些loading信息是一件挺吃力不讨好的事情。因为首先正确记录loading状态就不是个容易的事情，很可能必须得用<code>API名字 + 参数</code>为key来记录，在使用的时候也必须小心地使用<code>API名字 + 参数</code>去拿到这个值。其次，这些loading状态可能只是一个component需要的局部UI状态，当API请求结束，loading状态的使命也宣告结束，没有存在的必要了，也就不应该存在redux里。</p>\n<p>遇到这种问题，建议把loading放在Component内部的state中，用callback触发setState，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateUserName</span>(<span class=\"params\">userId, name, callback = (</span>) =&gt; </span>&#123;&#125;) &#123; <span class=\"comment\">// 注意多了一个callback参数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">dispatch</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    request.put(<span class=\"string\">'/api/user-name/'</span> + userId)</span><br><span class=\"line\">    .then(<span class=\"function\">(<span class=\"params\">user</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">        type: UPDATE_ONE_USER,</span><br><span class=\"line\">        payload: &#123; user &#125;,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> callback(err));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///////////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体在用的时候结合this.setState</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  updateUserName(userId, name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">isUpdating</span>: <span class=\"literal\">true</span> &#125;); <span class=\"comment\">// &lt;-- loading开始</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.updateUserName(userId, name, (err) =&gt; &#123; <span class=\"comment\">// 通过callback调用setState</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">isUpdating</span>: <span class=\"literal\">false</span> &#125;); <span class=\"comment\">// &lt;-- loading结束</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"entities足以，idList慎用\"><a href=\"#entities足以，idList慎用\" class=\"headerlink\" title=\"entities足以，idList慎用\"></a>entities足以，idList慎用</h2><p>entities指的是一种map数据结构，内容为 id -&gt; data。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userEntities = &#123;</span><br><span class=\"line\">  [user1.id]: user1,</span><br><span class=\"line\">  [user2.id]: user2,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">jobEntities = &#123;</span><br><span class=\"line\">  [job1.id]: job1,</span><br><span class=\"line\">  [job2.id]: job2,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于列表数据，一种常见的做法是用entities存储数据，然后用idList来表示顺序。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userEntities = &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: user1,</span><br><span class=\"line\">  <span class=\"number\">2</span>: user2,</span><br><span class=\"line\">  <span class=\"number\">3</span>: user3,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ascIdList = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]; <span class=\"comment\">// 顺序排列</span></span><br><span class=\"line\">descIdList = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// 逆序排列</span></span><br><span class=\"line\">myIdList = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]; <span class=\"comment\">// 其他特殊的排列顺序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// render的时候只要按照idList进行map即可：</span></span><br><span class=\"line\">ascUsers = ascIdList.map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">descUsers = descIdList.map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">myUsers = myIdList.map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br></pre></td></tr></table></figure>\n<p>这种组织state的方式有一个最大的问题，那就是当涉及到数据变化的时候，所有相关的idList也需要改动，不然就会发生问题。比如删掉了id是2的user，那么三个idList都要做一遍filter，去掉2。</p>\n<p>为了避免这种数据改动导致idList被牵连改动的问题，另一种做法是完全不用idList，而是在使用的地方就地排序。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userEntities = &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: user1，</span><br><span class=\"line\">  <span class=\"number\">2</span>: user2,</span><br><span class=\"line\">  <span class=\"number\">3</span>: user3,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有idList，用到的时候现场排序</span></span><br><span class=\"line\">ascUser = <span class=\"built_in\">Object</span>.keys(userEntities).sort(ascCompare).map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">descUser = <span class=\"built_in\">Object</span>.keys(userEntities.sort(descCompare).map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br><span class=\"line\">myUser = <span class=\"built_in\">Object</span>.keys(userEntities.sort(myCompare).map(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> userEntities[id]);</span><br></pre></td></tr></table></figure>\n<p>不过呢，上面这个做法虽然避免了idList的牵连改动，但每次使用的时候都要sort，性能上有一定影响。没关系，这个可以用memoized function解决。比如使用reselect。</p>\n<p>所以，大部分时候用entities就够了，引入idList可能会更麻烦</p>\n<h2 id=\"只要你愿意，什么组件都可以connect到redux-store\"><a href=\"#只要你愿意，什么组件都可以connect到redux-store\" class=\"headerlink\" title=\"只要你愿意，什么组件都可以connect到redux store\"></a>只要你愿意，什么组件都可以connect到redux store</h2><p>redux 作者推荐的一种使用redux的方式是将connect用作container组件，将具体的render逻辑放在presentation组件中。这样，data source和data presentation就可以解耦，便于替换和复用。</p>\n<p>理论上，只要你愿意，任何组件只要connect到redux store，就可以做container组件。然而很多人认为选择哪些组件做container是十分有讲究的。有些人认为只有顶层组件才是container组件，例如APP组件；有些人认为router组件算是container组件。哪一种是对的呢？</p>\n<p>回到问题的根本，为什么我们要求不是所有组件都可以connect呢？主要原因还是便于测试，进而提高代码可靠性。当然也有一些性能上的考虑，但在大多数情况下，性能都不是主要考虑的问题。</p>\n<p>所以，限制只有某些组件才能做container的做法，初衷是为了保证代码单元测试起来更加容易。这其实不是一个很强力的观点，因为99%前端工程都没有单元测试，强行用这种观点去实践，反而会给开发带来额外的麻烦。</p>\n<p>也许你见过这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是 container 组件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ContainerComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;MiddleComponent</span><br><span class=\"line\">        a=&#123;<span class=\"keyword\">this</span>.props.a&#125;</span><br><span class=\"line\">        b=&#123;<span class=\"keyword\">this</span>.props.b&#125;</span><br><span class=\"line\">        c=&#123;<span class=\"keyword\">this</span>.props.c&#125;</span><br><span class=\"line\">        d=&#123;<span class=\"keyword\">this</span>.props.d&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MiddleComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;InnerComponent</span><br><span class=\"line\">        a=&#123;<span class=\"keyword\">this</span>.props.a&#125; <span class=\"comment\">// &lt;-- a、b、c、d这些属性对MiddleComponent完全没有意义，只是原封不动地传给了InnerComponent</span></span><br><span class=\"line\">        b=&#123;<span class=\"keyword\">this</span>.props.b&#125;</span><br><span class=\"line\">        c=&#123;<span class=\"keyword\">this</span>.props.c&#125;</span><br><span class=\"line\">        d=&#123;<span class=\"keyword\">this</span>.props.d&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到这种代码，我立刻就想到了“酒肉穿肠过，佛祖心中留”。借用王银曾经评论haskell的比喻，这就好比是一个没有无线电的世界，所有的信号传递都只能通过一根根电线链接两头。</p>\n<p>为了避免上面那种壮丽的景象，有人选择这么写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MiddleComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;InnerComponent &#123;...this.props&#125;/&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种写法看似简单了很多，但由于props的传递是隐式的，开发者要弄清究竟传了什么，就必须回溯到最开始的container组件。这就好比一些数学教材中的证明答案：由第xx题的证明结论，可以得到blablabla。但是你去看第XX题，发现也是一样的：由第YY题的证明结论可以得到blablabla。然后你又要去看YY题的证明过程，可能得到的还是类似的东西。。</p>\n<p>再多说一句，凡是隐式的、动态的写法，基本都是有害的。因为写的时候你爽了，以后其他人维护代码的时候就会被坑惨了。</p>\n<p>所以，不要迷信什么必须只有顶层容器才能connect之类的best practice，大胆connect吧，只要别再common组件里connect就行（common组件不要混入业务逻辑，也就不要connect）。</p>\n<h2 id=\"避免嵌套过深的state结构\"><a href=\"#避免嵌套过深的state结构\" class=\"headerlink\" title=\"避免嵌套过深的state结构\"></a>避免嵌套过深的state结构</h2><p>这个道理很容易理解，越是嵌套深，越是不容易修改（因为要return新的state），不懂的话吃过亏也就懂了。</p>\n"},{"title":"如何正确使用h1 h2 h3","date":"2016-02-14T13:29:18.000Z","_content":"\n`h1`，`h2`，`h3`，`h4`，`h5`，`h6`（以下简称`h1~6`）是 html 的原生标签，虽然今天并不常用。\n\n## h1~6 帮助裸奔的页面穿上底裤\n\n1995 年 9 月，[国际互联网工程任务组（IETF）](https://www.ietf.org/) 正式颁布了 超文本标记语言（HTML）的第一个标准 —— [IETF RFC 1866](https://tools.ietf.org/html/rfc1866)，即 HTML 2.0 。其中就包含了 `h1~6`。\n\n> Headings: H1 ... H6\n> The six heading elements, <H1\\> through <H6\\>, denote section headings.\n   Although the order and occurrence of headings is not constrained by\n   the HTML DTD, documents should not skip levels (for example, from H1\n   to H3), as converting such documents to other representations is\n   often problematic.\n\n受限于浏览器的性能以及网络带宽，当时的页面主要是以文字+少量图片的形式呈现的，甚至大部分页面都是裸奔状态（没有设置任何css效果）。这种以文本内容为主的页面其实跟我们今天使用 Markdown 写成的文档比较类似，只需要将重点放在文字的样式上就够了。因而使用 h1~6 的好处就非常明显，因为浏览器针对这些标签都会有特定的样式效果，不用额外书写css也能让页面看上去“美观”。\n\n根据 [W3C 的 html4 文档标准](https://www.w3.org/TR/CSS2/sample.html)，h1~6 主要具有下列默认风格：\n\n```css\nh1, h2, h3, h4, h5, h6 {\n  display: block;\n  unicode-bidi: embed;\n  font-weight: bolder;\n}\n\nh1 {\n  font-size: 2em;\n  margin: .67em 0;\n}\n\nh2 {\n  font-size: 1.5em;\n  margin: .75em 0;\n}\n\nh3 {\n  font-size: 1.17em;\n  margin: .83em 0;\n}\n\nh4 {\n  margin: 1.12em 0;\n}\n\nh5 {\n  font-size: .83em;\n  margin: 1.5em 0;\n}\n\nh6 {\n  font-size: .75em;\n  margin: 1.67em 0;\n}\n```\n\n简单来说就是\n1. `h1~6` 自带加粗效果\n2. `h1~3` 比普通文本字号大，`h4` 跟普通文本字号一样，`h5~6` 比普通文本小\n3. `h1~6` 是 `block` 元素，自带上下边距\n\n\n## h1~6 默认样式的可用性几乎为零\n\n上面也提到了，`h1~6` 是自带默认效果的，这对早期的裸奔页面非常重要，但是在今天的网页设计中几乎是毫无作用的。因为那些默认效果恰好匹配上页面设计图的概率几乎为零，所以通常你都需要用自己的样式覆盖默认的效果（字号、粗细、上下边距、display 效果，等等等等）。\n\n所以，**不要从样式的角度考虑是否用 h1~6 以及该用他们中的哪一个**。你就当他们跟 `p` 标签一样没有任何效果吧。\n\n\n## h1~6 的语义化效果极其有限\n\n大部分人使用 `h1~6` 想必是因为看中了其语义化标签的特点。\n\n> 你看，这里使用 h1，开发人员一眼看过去就知道这是标题，多么清楚。\n\n这其实是一种自欺欺人的想法。首先，开发人员有必要知道“这是标题”吗？就算知道它是标题，你又能怎样？如果是为了设置样式，还不是得乖乖使用 `class`。但是既然都已经用到描述能力更强的 `class`，还有必要纠结 `h1~6` 仅有的一点点语义信息吗？\n\n- 一个开发者见到 h1，那他能知道什么呢？\n- 一个开发者见到 `.settings__user-profile__title`，他又能知道什么呢？\n\n你完全可以通过合理命名的 `class` 属性体现“语义化”特性，不但更灵活，而且更有效。\n\n\n## h1~6 很容易被滥用\n\n既然 `h1~6` 都表示标题，那么问题来了，什么样的标题应该用 `h1`，什么样的标题应该用 `h2`，什么样的标题应该用 `h3` ...\n\n你会发现，当你的页面几乎都是文字的时候，这个问题很好区分。\n\n```\n1.\n  1.1\n  1.2\n    1.2.1\n    1.2.2\n    1.2.3\n  1.3\n2.\n  2.1\n  2.2\n  2.3\n```\n上面的文章结构可以跟 `h1~6` 无缝衔接。\n\n可是当你的页面充满了表格、弹窗、下拉菜单、导航条、图片、按钮的时候，你很难整理出像上面一样清晰的文档结构。此时，问题的答案就没有那么显然了。导航的标题，图片的标题、表格的标题、表单的标题、弹窗的标题、下拉的标题...\n\n你很快就会迷失在“这个标题应该用 `h1~6` 之中的哪一个”的问题里面。\n\n到最后，这些标签分散在各个页面里，你也不清楚自己在哪些地方用到了 `h1`， `h2`，`h3`。于是你开始自暴自弃，看心情使用，`h1~6` 的组织变得一团糟。\n\n假如开发者是一个团队，那上面的情况还要严重许多，为了规范代码，你不得不整理一份编码文档，用来规定什么地方用什么标签，除了督促成员遵守，还得定期更新维护。稍微一不小心，`h1~6` 就会混乱起来。\n\n> 使用一门灵活的语言对于个人开发是很方便的，但是对于团队开发将是灾难性的，因为你不得不在语法之外规定一长串的“编码规范”以保证整个团队产出的代码风格一致。语言本身语法的“约束”越少，“编码规范”就越长。\n\n如果彻底不用 `h1~6` 或者仅保留 `h1`，那么上面的问题就立即被解决了。这也是为什么有些大公司只允许使用 `h1` 的原因。\n\n\n## 总结\n\n`h1~6` 仅适用于以文字内容为主的页面，对于其他页面，顶多用到 `h1` 就够了。让 `h2~6` 见鬼去吧。\n","source":"_posts/how-to-use-h1-h2-h3.md","raw":"title: 如何正确使用h1 h2 h3\ndate: 2016-02-14 21:29:18\ntags: front-end\n---\n\n`h1`，`h2`，`h3`，`h4`，`h5`，`h6`（以下简称`h1~6`）是 html 的原生标签，虽然今天并不常用。\n\n## h1~6 帮助裸奔的页面穿上底裤\n\n1995 年 9 月，[国际互联网工程任务组（IETF）](https://www.ietf.org/) 正式颁布了 超文本标记语言（HTML）的第一个标准 —— [IETF RFC 1866](https://tools.ietf.org/html/rfc1866)，即 HTML 2.0 。其中就包含了 `h1~6`。\n\n> Headings: H1 ... H6\n> The six heading elements, <H1\\> through <H6\\>, denote section headings.\n   Although the order and occurrence of headings is not constrained by\n   the HTML DTD, documents should not skip levels (for example, from H1\n   to H3), as converting such documents to other representations is\n   often problematic.\n\n受限于浏览器的性能以及网络带宽，当时的页面主要是以文字+少量图片的形式呈现的，甚至大部分页面都是裸奔状态（没有设置任何css效果）。这种以文本内容为主的页面其实跟我们今天使用 Markdown 写成的文档比较类似，只需要将重点放在文字的样式上就够了。因而使用 h1~6 的好处就非常明显，因为浏览器针对这些标签都会有特定的样式效果，不用额外书写css也能让页面看上去“美观”。\n\n根据 [W3C 的 html4 文档标准](https://www.w3.org/TR/CSS2/sample.html)，h1~6 主要具有下列默认风格：\n\n```css\nh1, h2, h3, h4, h5, h6 {\n  display: block;\n  unicode-bidi: embed;\n  font-weight: bolder;\n}\n\nh1 {\n  font-size: 2em;\n  margin: .67em 0;\n}\n\nh2 {\n  font-size: 1.5em;\n  margin: .75em 0;\n}\n\nh3 {\n  font-size: 1.17em;\n  margin: .83em 0;\n}\n\nh4 {\n  margin: 1.12em 0;\n}\n\nh5 {\n  font-size: .83em;\n  margin: 1.5em 0;\n}\n\nh6 {\n  font-size: .75em;\n  margin: 1.67em 0;\n}\n```\n\n简单来说就是\n1. `h1~6` 自带加粗效果\n2. `h1~3` 比普通文本字号大，`h4` 跟普通文本字号一样，`h5~6` 比普通文本小\n3. `h1~6` 是 `block` 元素，自带上下边距\n\n\n## h1~6 默认样式的可用性几乎为零\n\n上面也提到了，`h1~6` 是自带默认效果的，这对早期的裸奔页面非常重要，但是在今天的网页设计中几乎是毫无作用的。因为那些默认效果恰好匹配上页面设计图的概率几乎为零，所以通常你都需要用自己的样式覆盖默认的效果（字号、粗细、上下边距、display 效果，等等等等）。\n\n所以，**不要从样式的角度考虑是否用 h1~6 以及该用他们中的哪一个**。你就当他们跟 `p` 标签一样没有任何效果吧。\n\n\n## h1~6 的语义化效果极其有限\n\n大部分人使用 `h1~6` 想必是因为看中了其语义化标签的特点。\n\n> 你看，这里使用 h1，开发人员一眼看过去就知道这是标题，多么清楚。\n\n这其实是一种自欺欺人的想法。首先，开发人员有必要知道“这是标题”吗？就算知道它是标题，你又能怎样？如果是为了设置样式，还不是得乖乖使用 `class`。但是既然都已经用到描述能力更强的 `class`，还有必要纠结 `h1~6` 仅有的一点点语义信息吗？\n\n- 一个开发者见到 h1，那他能知道什么呢？\n- 一个开发者见到 `.settings__user-profile__title`，他又能知道什么呢？\n\n你完全可以通过合理命名的 `class` 属性体现“语义化”特性，不但更灵活，而且更有效。\n\n\n## h1~6 很容易被滥用\n\n既然 `h1~6` 都表示标题，那么问题来了，什么样的标题应该用 `h1`，什么样的标题应该用 `h2`，什么样的标题应该用 `h3` ...\n\n你会发现，当你的页面几乎都是文字的时候，这个问题很好区分。\n\n```\n1.\n  1.1\n  1.2\n    1.2.1\n    1.2.2\n    1.2.3\n  1.3\n2.\n  2.1\n  2.2\n  2.3\n```\n上面的文章结构可以跟 `h1~6` 无缝衔接。\n\n可是当你的页面充满了表格、弹窗、下拉菜单、导航条、图片、按钮的时候，你很难整理出像上面一样清晰的文档结构。此时，问题的答案就没有那么显然了。导航的标题，图片的标题、表格的标题、表单的标题、弹窗的标题、下拉的标题...\n\n你很快就会迷失在“这个标题应该用 `h1~6` 之中的哪一个”的问题里面。\n\n到最后，这些标签分散在各个页面里，你也不清楚自己在哪些地方用到了 `h1`， `h2`，`h3`。于是你开始自暴自弃，看心情使用，`h1~6` 的组织变得一团糟。\n\n假如开发者是一个团队，那上面的情况还要严重许多，为了规范代码，你不得不整理一份编码文档，用来规定什么地方用什么标签，除了督促成员遵守，还得定期更新维护。稍微一不小心，`h1~6` 就会混乱起来。\n\n> 使用一门灵活的语言对于个人开发是很方便的，但是对于团队开发将是灾难性的，因为你不得不在语法之外规定一长串的“编码规范”以保证整个团队产出的代码风格一致。语言本身语法的“约束”越少，“编码规范”就越长。\n\n如果彻底不用 `h1~6` 或者仅保留 `h1`，那么上面的问题就立即被解决了。这也是为什么有些大公司只允许使用 `h1` 的原因。\n\n\n## 总结\n\n`h1~6` 仅适用于以文字内容为主的页面，对于其他页面，顶多用到 `h1` 就够了。让 `h2~6` 见鬼去吧。\n","slug":"how-to-use-h1-h2-h3","published":1,"updated":"2016-02-20T05:50:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkf0006u9yywnym9ccs","content":"<p><code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>（以下简称<code>h1~6</code>）是 html 的原生标签，虽然今天并不常用。</p>\n<h2 id=\"h1-6-帮助裸奔的页面穿上底裤\"><a href=\"#h1-6-帮助裸奔的页面穿上底裤\" class=\"headerlink\" title=\"h1~6 帮助裸奔的页面穿上底裤\"></a>h1~6 帮助裸奔的页面穿上底裤</h2><p>1995 年 9 月，<a href=\"https://www.ietf.org/\" target=\"_blank\" rel=\"noopener\">国际互联网工程任务组（IETF）</a> 正式颁布了 超文本标记语言（HTML）的第一个标准 —— <a href=\"https://tools.ietf.org/html/rfc1866\" target=\"_blank\" rel=\"noopener\">IETF RFC 1866</a>，即 HTML 2.0 。其中就包含了 <code>h1~6</code>。</p>\n<blockquote>\n<p>Headings: H1 … H6<br>The six heading elements, &lt;H1> through &lt;H6>, denote section headings.<br>   Although the order and occurrence of headings is not constrained by<br>   the HTML DTD, documents should not skip levels (for example, from H1<br>   to H3), as converting such documents to other representations is<br>   often problematic.</p>\n</blockquote>\n<p>受限于浏览器的性能以及网络带宽，当时的页面主要是以文字+少量图片的形式呈现的，甚至大部分页面都是裸奔状态（没有设置任何css效果）。这种以文本内容为主的页面其实跟我们今天使用 Markdown 写成的文档比较类似，只需要将重点放在文字的样式上就够了。因而使用 h1~6 的好处就非常明显，因为浏览器针对这些标签都会有特定的样式效果，不用额外书写css也能让页面看上去“美观”。</p>\n<p>根据 <a href=\"https://www.w3.org/TR/CSS2/sample.html\" target=\"_blank\" rel=\"noopener\">W3C 的 html4 文档标准</a>，h1~6 主要具有下列默认风格：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span>, <span class=\"selector-tag\">h3</span>, <span class=\"selector-tag\">h4</span>, <span class=\"selector-tag\">h5</span>, <span class=\"selector-tag\">h6</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">unicode-bidi</span>: embed;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: bolder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: .<span class=\"number\">67em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: .<span class=\"number\">75em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.17em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: .<span class=\"number\">83em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h4</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1.12em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h5</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: .<span class=\"number\">83em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1.5em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h6</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: .<span class=\"number\">75em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1.67em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说就是</p>\n<ol>\n<li><code>h1~6</code> 自带加粗效果</li>\n<li><code>h1~3</code> 比普通文本字号大，<code>h4</code> 跟普通文本字号一样，<code>h5~6</code> 比普通文本小</li>\n<li><code>h1~6</code> 是 <code>block</code> 元素，自带上下边距</li>\n</ol>\n<h2 id=\"h1-6-默认样式的可用性几乎为零\"><a href=\"#h1-6-默认样式的可用性几乎为零\" class=\"headerlink\" title=\"h1~6 默认样式的可用性几乎为零\"></a>h1~6 默认样式的可用性几乎为零</h2><p>上面也提到了，<code>h1~6</code> 是自带默认效果的，这对早期的裸奔页面非常重要，但是在今天的网页设计中几乎是毫无作用的。因为那些默认效果恰好匹配上页面设计图的概率几乎为零，所以通常你都需要用自己的样式覆盖默认的效果（字号、粗细、上下边距、display 效果，等等等等）。</p>\n<p>所以，<strong>不要从样式的角度考虑是否用 h1~6 以及该用他们中的哪一个</strong>。你就当他们跟 <code>p</code> 标签一样没有任何效果吧。</p>\n<h2 id=\"h1-6-的语义化效果极其有限\"><a href=\"#h1-6-的语义化效果极其有限\" class=\"headerlink\" title=\"h1~6 的语义化效果极其有限\"></a>h1~6 的语义化效果极其有限</h2><p>大部分人使用 <code>h1~6</code> 想必是因为看中了其语义化标签的特点。</p>\n<blockquote>\n<p>你看，这里使用 h1，开发人员一眼看过去就知道这是标题，多么清楚。</p>\n</blockquote>\n<p>这其实是一种自欺欺人的想法。首先，开发人员有必要知道“这是标题”吗？就算知道它是标题，你又能怎样？如果是为了设置样式，还不是得乖乖使用 <code>class</code>。但是既然都已经用到描述能力更强的 <code>class</code>，还有必要纠结 <code>h1~6</code> 仅有的一点点语义信息吗？</p>\n<ul>\n<li>一个开发者见到 h1，那他能知道什么呢？</li>\n<li>一个开发者见到 <code>.settings__user-profile__title</code>，他又能知道什么呢？</li>\n</ul>\n<p>你完全可以通过合理命名的 <code>class</code> 属性体现“语义化”特性，不但更灵活，而且更有效。</p>\n<h2 id=\"h1-6-很容易被滥用\"><a href=\"#h1-6-很容易被滥用\" class=\"headerlink\" title=\"h1~6 很容易被滥用\"></a>h1~6 很容易被滥用</h2><p>既然 <code>h1~6</code> 都表示标题，那么问题来了，什么样的标题应该用 <code>h1</code>，什么样的标题应该用 <code>h2</code>，什么样的标题应该用 <code>h3</code> …</p>\n<p>你会发现，当你的页面几乎都是文字的时候，这个问题很好区分。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span></span><br><span class=\"line\">  <span class=\"number\">1.1</span></span><br><span class=\"line\">  <span class=\"number\">1.2</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span><span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span><span class=\"number\">.3</span></span><br><span class=\"line\">  <span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"number\">2.</span></span><br><span class=\"line\">  <span class=\"number\">2.1</span></span><br><span class=\"line\">  <span class=\"number\">2.2</span></span><br><span class=\"line\">  <span class=\"number\">2.3</span></span><br></pre></td></tr></table></figure>\n<p>上面的文章结构可以跟 <code>h1~6</code> 无缝衔接。</p>\n<p>可是当你的页面充满了表格、弹窗、下拉菜单、导航条、图片、按钮的时候，你很难整理出像上面一样清晰的文档结构。此时，问题的答案就没有那么显然了。导航的标题，图片的标题、表格的标题、表单的标题、弹窗的标题、下拉的标题…</p>\n<p>你很快就会迷失在“这个标题应该用 <code>h1~6</code> 之中的哪一个”的问题里面。</p>\n<p>到最后，这些标签分散在各个页面里，你也不清楚自己在哪些地方用到了 <code>h1</code>， <code>h2</code>，<code>h3</code>。于是你开始自暴自弃，看心情使用，<code>h1~6</code> 的组织变得一团糟。</p>\n<p>假如开发者是一个团队，那上面的情况还要严重许多，为了规范代码，你不得不整理一份编码文档，用来规定什么地方用什么标签，除了督促成员遵守，还得定期更新维护。稍微一不小心，<code>h1~6</code> 就会混乱起来。</p>\n<blockquote>\n<p>使用一门灵活的语言对于个人开发是很方便的，但是对于团队开发将是灾难性的，因为你不得不在语法之外规定一长串的“编码规范”以保证整个团队产出的代码风格一致。语言本身语法的“约束”越少，“编码规范”就越长。</p>\n</blockquote>\n<p>如果彻底不用 <code>h1~6</code> 或者仅保留 <code>h1</code>，那么上面的问题就立即被解决了。这也是为什么有些大公司只允许使用 <code>h1</code> 的原因。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>h1~6</code> 仅适用于以文字内容为主的页面，对于其他页面，顶多用到 <code>h1</code> 就够了。让 <code>h2~6</code> 见鬼去吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>（以下简称<code>h1~6</code>）是 html 的原生标签，虽然今天并不常用。</p>\n<h2 id=\"h1-6-帮助裸奔的页面穿上底裤\"><a href=\"#h1-6-帮助裸奔的页面穿上底裤\" class=\"headerlink\" title=\"h1~6 帮助裸奔的页面穿上底裤\"></a>h1~6 帮助裸奔的页面穿上底裤</h2><p>1995 年 9 月，<a href=\"https://www.ietf.org/\" target=\"_blank\" rel=\"noopener\">国际互联网工程任务组（IETF）</a> 正式颁布了 超文本标记语言（HTML）的第一个标准 —— <a href=\"https://tools.ietf.org/html/rfc1866\" target=\"_blank\" rel=\"noopener\">IETF RFC 1866</a>，即 HTML 2.0 。其中就包含了 <code>h1~6</code>。</p>\n<blockquote>\n<p>Headings: H1 … H6<br>The six heading elements, &lt;H1> through &lt;H6>, denote section headings.<br>   Although the order and occurrence of headings is not constrained by<br>   the HTML DTD, documents should not skip levels (for example, from H1<br>   to H3), as converting such documents to other representations is<br>   often problematic.</p>\n</blockquote>\n<p>受限于浏览器的性能以及网络带宽，当时的页面主要是以文字+少量图片的形式呈现的，甚至大部分页面都是裸奔状态（没有设置任何css效果）。这种以文本内容为主的页面其实跟我们今天使用 Markdown 写成的文档比较类似，只需要将重点放在文字的样式上就够了。因而使用 h1~6 的好处就非常明显，因为浏览器针对这些标签都会有特定的样式效果，不用额外书写css也能让页面看上去“美观”。</p>\n<p>根据 <a href=\"https://www.w3.org/TR/CSS2/sample.html\" target=\"_blank\" rel=\"noopener\">W3C 的 html4 文档标准</a>，h1~6 主要具有下列默认风格：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span>, <span class=\"selector-tag\">h3</span>, <span class=\"selector-tag\">h4</span>, <span class=\"selector-tag\">h5</span>, <span class=\"selector-tag\">h6</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">unicode-bidi</span>: embed;</span><br><span class=\"line\">  <span class=\"attribute\">font-weight</span>: bolder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">2em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: .<span class=\"number\">67em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: .<span class=\"number\">75em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.17em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: .<span class=\"number\">83em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h4</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1.12em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h5</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: .<span class=\"number\">83em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1.5em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h6</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: .<span class=\"number\">75em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1.67em</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说就是</p>\n<ol>\n<li><code>h1~6</code> 自带加粗效果</li>\n<li><code>h1~3</code> 比普通文本字号大，<code>h4</code> 跟普通文本字号一样，<code>h5~6</code> 比普通文本小</li>\n<li><code>h1~6</code> 是 <code>block</code> 元素，自带上下边距</li>\n</ol>\n<h2 id=\"h1-6-默认样式的可用性几乎为零\"><a href=\"#h1-6-默认样式的可用性几乎为零\" class=\"headerlink\" title=\"h1~6 默认样式的可用性几乎为零\"></a>h1~6 默认样式的可用性几乎为零</h2><p>上面也提到了，<code>h1~6</code> 是自带默认效果的，这对早期的裸奔页面非常重要，但是在今天的网页设计中几乎是毫无作用的。因为那些默认效果恰好匹配上页面设计图的概率几乎为零，所以通常你都需要用自己的样式覆盖默认的效果（字号、粗细、上下边距、display 效果，等等等等）。</p>\n<p>所以，<strong>不要从样式的角度考虑是否用 h1~6 以及该用他们中的哪一个</strong>。你就当他们跟 <code>p</code> 标签一样没有任何效果吧。</p>\n<h2 id=\"h1-6-的语义化效果极其有限\"><a href=\"#h1-6-的语义化效果极其有限\" class=\"headerlink\" title=\"h1~6 的语义化效果极其有限\"></a>h1~6 的语义化效果极其有限</h2><p>大部分人使用 <code>h1~6</code> 想必是因为看中了其语义化标签的特点。</p>\n<blockquote>\n<p>你看，这里使用 h1，开发人员一眼看过去就知道这是标题，多么清楚。</p>\n</blockquote>\n<p>这其实是一种自欺欺人的想法。首先，开发人员有必要知道“这是标题”吗？就算知道它是标题，你又能怎样？如果是为了设置样式，还不是得乖乖使用 <code>class</code>。但是既然都已经用到描述能力更强的 <code>class</code>，还有必要纠结 <code>h1~6</code> 仅有的一点点语义信息吗？</p>\n<ul>\n<li>一个开发者见到 h1，那他能知道什么呢？</li>\n<li>一个开发者见到 <code>.settings__user-profile__title</code>，他又能知道什么呢？</li>\n</ul>\n<p>你完全可以通过合理命名的 <code>class</code> 属性体现“语义化”特性，不但更灵活，而且更有效。</p>\n<h2 id=\"h1-6-很容易被滥用\"><a href=\"#h1-6-很容易被滥用\" class=\"headerlink\" title=\"h1~6 很容易被滥用\"></a>h1~6 很容易被滥用</h2><p>既然 <code>h1~6</code> 都表示标题，那么问题来了，什么样的标题应该用 <code>h1</code>，什么样的标题应该用 <code>h2</code>，什么样的标题应该用 <code>h3</code> …</p>\n<p>你会发现，当你的页面几乎都是文字的时候，这个问题很好区分。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span></span><br><span class=\"line\">  <span class=\"number\">1.1</span></span><br><span class=\"line\">  <span class=\"number\">1.2</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span><span class=\"number\">.2</span></span><br><span class=\"line\">    <span class=\"number\">1.2</span><span class=\"number\">.3</span></span><br><span class=\"line\">  <span class=\"number\">1.3</span></span><br><span class=\"line\"><span class=\"number\">2.</span></span><br><span class=\"line\">  <span class=\"number\">2.1</span></span><br><span class=\"line\">  <span class=\"number\">2.2</span></span><br><span class=\"line\">  <span class=\"number\">2.3</span></span><br></pre></td></tr></table></figure>\n<p>上面的文章结构可以跟 <code>h1~6</code> 无缝衔接。</p>\n<p>可是当你的页面充满了表格、弹窗、下拉菜单、导航条、图片、按钮的时候，你很难整理出像上面一样清晰的文档结构。此时，问题的答案就没有那么显然了。导航的标题，图片的标题、表格的标题、表单的标题、弹窗的标题、下拉的标题…</p>\n<p>你很快就会迷失在“这个标题应该用 <code>h1~6</code> 之中的哪一个”的问题里面。</p>\n<p>到最后，这些标签分散在各个页面里，你也不清楚自己在哪些地方用到了 <code>h1</code>， <code>h2</code>，<code>h3</code>。于是你开始自暴自弃，看心情使用，<code>h1~6</code> 的组织变得一团糟。</p>\n<p>假如开发者是一个团队，那上面的情况还要严重许多，为了规范代码，你不得不整理一份编码文档，用来规定什么地方用什么标签，除了督促成员遵守，还得定期更新维护。稍微一不小心，<code>h1~6</code> 就会混乱起来。</p>\n<blockquote>\n<p>使用一门灵活的语言对于个人开发是很方便的，但是对于团队开发将是灾难性的，因为你不得不在语法之外规定一长串的“编码规范”以保证整个团队产出的代码风格一致。语言本身语法的“约束”越少，“编码规范”就越长。</p>\n</blockquote>\n<p>如果彻底不用 <code>h1~6</code> 或者仅保留 <code>h1</code>，那么上面的问题就立即被解决了。这也是为什么有些大公司只允许使用 <code>h1</code> 的原因。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>h1~6</code> 仅适用于以文字内容为主的页面，对于其他页面，顶多用到 <code>h1</code> 就够了。让 <code>h2~6</code> 见鬼去吧。</p>\n"},{"title":"钉钉ISV开发杂谈","date":"2016-08-30T15:34:04.000Z","_content":"\n## 钉钉开发大致分为以下几个部分\n1. 接入\n2. 服务端开发\n3. 桌面端开发\n4. 移动端开发\n\n------\n\n## 接入\n\n这里忽略正式接入之前的各种手续（注册开发账号、企业认证等等）\n\n接入的流程十分繁琐，这其中相当重要的一部分工作是做到正确响应钉钉服务器的推送消息。可以认为“接入”指的就是把架子搭起来，做到正确响应钉钉推送。钉钉认为，如果开发者连这个都做不到，就不应该准许你继续后面的开发工作（不给你创建套件）。而只有完成了基础框架，才能够创建开发套件，才算是入了门了。估计这就是叫“接入”的原因。\n\n钉钉服务器的推送看上去不多，也就7种，分为5类。必须正确相应所有的推送请求才算完。目前没有相应的node sdk，只能自己写。如果只是单纯为了响应请求（比如返回一个success）那是很容易的，复杂的地方在于一些推送之间存在关联关系，而要正确处理则往往涉及到数据持久化操作，所以很容易跟业务逻辑耦合起来。\n\n接入又分为企业接入和ISV接入两种。企业接入指的是开发企业专属的定制化钉钉应用，这个应用无法发布出去，只能在某一个企业内部使用。而ISV与前者的区别在于是可发布的，能够被不同企业安装使用。可以看出，SaaS公司通常都会选择ISV接入。企业接入由于无法发布，所以在接入流程上相比ISV接入要简化许多。\n\n钉钉官方文档中给的这个流程图非常好，看懂下面这张图，ISV的接入部分就没有问题了\n\n![钉钉ISV接入流程](https://img.alicdn.com/tps/TB1Fm1HJVXXXXXFaXXXXXXXXXXX-2376-1880.jpg)\n\n最后，一句话总结，接入部分的工作就是做到能够正确相应钉钉服务器的推送。\n\n------\n\n## 开发\n\n由于不涉及到桌面端开发，所以这里只讲移动端和服务端。\n\n服务端的开发与普通web后端开发没什么不同，移动端开发无非是调用了一下钉钉专属的jsapi，也没有什么难点。唯一的困难是正确使用钉钉接口以及理解各种名词，下面只列举一些比较关键的概念。\n\n### suite\n钉钉应用的开发是以套件为单位的。套件是一组应用的容器，可以用手机桌面上的应用文件夹来比喻。套件本身不包含任何业务逻辑，没有应用的套件是无法发布的。套件主要涉及的是钉钉企业认证、授权部分，所以也可将套件理解为钉钉的最小授权单位。套件也是钉钉的最小发布单位。当套件被企业授权后，企业钉钉内部将出现套件入口，企业内的员工就可以使用套件内的应用了。有意思的是，在发布套件出去的时候，可以指定套件内需要发布的应用，不一定要全部发布出去。\n\n### app\napp是钉钉应用的最小功能单位，本质上是一个H5应用，一个钉钉套件可以最多包含9个app（目前钉钉开发后台创建了app没法删除，这个需要注意一下）。从严格意义上看，授权过程实际上是将app与企业进行绑定（这个是钉钉后台干的事情）。然而在ISV里更常使用agent而不是app，这两个概念有一些细微差别。\n\n### agent\n在ISV接入中，app经过企业授权后，将以agent的形式出现。可以认为，app与企业经过绑定后，就变成了agent。实际上从功能的角度上看，agent就是app。\n\n### 免登\n免登的意思就是“免登陆”，有些操作需要登陆才有权限（例如拿到用户的身份信息，当然这里的登陆不是真的登陆，只是一种授权形式），如果不使用免登，则需要用户手动登陆授权，不是很友好，免登则可以解决这个问题。目前已知在钉钉开发过程中需要用到免登的大概有三种场景：1. 登陆钉钉用户账号 2. 登陆钉钉企业后台管理（SSO）。前者很常用，后者通常不会用到。而登陆钉钉用户账号其实又分为两种，一种是用户信息授权（只能拿到用户的手机号、工号等信息），另一种是获取用户操作权限（可以以用户的身份发消息等操作）。\n\n#### jsapi\n钉钉前端js接口，使用方式上与微信的JSSDK类似，但功能要强大得多。\n\n### 回调模式\n钉钉服务器主动向ISV服务器推送消息，这种行为模式被称作回调模式。前面所说的ISV接入的工作主要是就是与回调模式打交道。\n\n### 主动调用模式\nISV服务器除了被动接收钉钉服务器推送消息外，也可以主动向钉钉服务器发送请求。这种行为模式被称作主动调用模式。\n\n### saltUI\n钉钉开发的一套前端框架，除了提供一般前端框架抽象好的组件外，还具有类似页面过渡等高级效果，可以更好地模拟本地应用的效果。比较遗憾的是saltUI依赖钉钉SDK，因此只能用来开发钉钉应用。\n\n------\n\n## 需要注意的地方\n\n### 一定要持久化保存 suite_ticket\nsuite_ticket是万物之源，所有后续流程都直接或间接依赖suite_ticket。suite_ticket的有效时间是20分钟，钉钉服务器会每20分钟推送一次最新的suite_ticket，这个是开发者不可控的。因此suite_ticket一定要持久化保存。此外，钉钉如果没有收到suite_ticket推送的响应，最多推送100次后就会停止推送。所以如果你的服务器宕机比较久，重启以后需要手动去ISV开发后台重启推送。这个挺容易理解，就是有时候会忘掉。\n\n### 企业授权认证注意实现容错机制\n钉钉文档中警告我们，如果认证过程没有正常完成，比如弄丢了临时授权码或永久授权码，那企业是无法正常使用钉钉应用的，而且也无法再次授权（会提示已授权）。所以，我们需要做好容错机制，比如持久化保存临时授权码，这样如果宕机不至于丢失。\n不过这个问题倒也不是非常严重，因为企业本身可以通过取消授权、再次授权的方式重启授权过程。\n\n### 谨慎生成线下部署二维码\n开发好的ISV应用有两种发布方式：线上（上架钉钉市场）、线下（扫二维码授权安装）。这个二维码不是你想生成就生成的，跟创建套件一样，在创建过程中，钉钉服务器会对应用进行功能验证（推送一些消息，看能否正常返回），如果有错误是生成不了二维码的。\n这里有一个非常坑的地方，生成线下部署二维码的时候，钉钉主要验证你是否实现了企业授权流程。它会先用一个测试企业向你发起授权，然后你需要保存好授权得到的永久授权码。如果不小心把永久授权码弄丢了，验证过程将永远无法通过，你也就永远别想生成线二维码了。唯一的解决办法是去找钉钉工作人员手动给你解除授权。\n\n### 本地测试记得改套件配置\n钉钉本地调试还是比较友好的，只要你的机器可以被外网访问就行。但在本地测试前记得修改钉钉套件的回调url以及套件内应用的首页地址。有时候这些配置还会写在代码的config文件里，所以那里面也要记得修改。这个过程稍微有些麻烦，但还可以接受。\n\n### 钉钉应用入口是唯一可以凭空获取corpId的地方\n只有点击钉钉应用进入页面的方式才能获取到corpId，其他打开方式例如直接打开应用内页面链接是无法拿到corpId的。而只有拿到corpId，才可以一步步拿到最终的钉钉用户id，所以corpId非常重要。这就引出一个问题，如果就是想通过链接打开钉钉应用页面呢？（比如一个带链接的通知）没有别的办法，只能在链接中附带上corpId的信息（或者用token屏蔽一次）。有时候为了方便，甚至直接把获取到的钉钉用户id也放在url的query部分了，看着像是把内裤穿在外面，确实欠妥但简单粗暴有效。\n\n### chrome远程调试谁用谁知道\n钉钉Android开发者版本可以借助chrome远程调试，非常好用。iOS版则有些鸡肋，只能安装在虚拟机上。要知道有些问题必须在真机上才能发现，所以还是推荐Android版本。\n\n### js文件不能过大\n钉钉文档中没有明说，但根据钉钉开发人员的建议，单个js文件最好不要超过1MB，否则钉钉会拒绝加载。这个限制对于习惯了webpack hmr的开发者来说非常蛋疼，因为webpack打包好的bundle随随便便就超过1MB了。要么对webpack打包进行优化，比如拆分、动态加载之类的，要么就放弃hmr，每次都打包成minified的版本。\n","source":"_posts/dingding-isv-development-tips.md","raw":"title: 钉钉ISV开发杂谈\ndate: 2016-08-30 23:34:04\ntags: dingtalk isv\n---\n\n## 钉钉开发大致分为以下几个部分\n1. 接入\n2. 服务端开发\n3. 桌面端开发\n4. 移动端开发\n\n------\n\n## 接入\n\n这里忽略正式接入之前的各种手续（注册开发账号、企业认证等等）\n\n接入的流程十分繁琐，这其中相当重要的一部分工作是做到正确响应钉钉服务器的推送消息。可以认为“接入”指的就是把架子搭起来，做到正确响应钉钉推送。钉钉认为，如果开发者连这个都做不到，就不应该准许你继续后面的开发工作（不给你创建套件）。而只有完成了基础框架，才能够创建开发套件，才算是入了门了。估计这就是叫“接入”的原因。\n\n钉钉服务器的推送看上去不多，也就7种，分为5类。必须正确相应所有的推送请求才算完。目前没有相应的node sdk，只能自己写。如果只是单纯为了响应请求（比如返回一个success）那是很容易的，复杂的地方在于一些推送之间存在关联关系，而要正确处理则往往涉及到数据持久化操作，所以很容易跟业务逻辑耦合起来。\n\n接入又分为企业接入和ISV接入两种。企业接入指的是开发企业专属的定制化钉钉应用，这个应用无法发布出去，只能在某一个企业内部使用。而ISV与前者的区别在于是可发布的，能够被不同企业安装使用。可以看出，SaaS公司通常都会选择ISV接入。企业接入由于无法发布，所以在接入流程上相比ISV接入要简化许多。\n\n钉钉官方文档中给的这个流程图非常好，看懂下面这张图，ISV的接入部分就没有问题了\n\n![钉钉ISV接入流程](https://img.alicdn.com/tps/TB1Fm1HJVXXXXXFaXXXXXXXXXXX-2376-1880.jpg)\n\n最后，一句话总结，接入部分的工作就是做到能够正确相应钉钉服务器的推送。\n\n------\n\n## 开发\n\n由于不涉及到桌面端开发，所以这里只讲移动端和服务端。\n\n服务端的开发与普通web后端开发没什么不同，移动端开发无非是调用了一下钉钉专属的jsapi，也没有什么难点。唯一的困难是正确使用钉钉接口以及理解各种名词，下面只列举一些比较关键的概念。\n\n### suite\n钉钉应用的开发是以套件为单位的。套件是一组应用的容器，可以用手机桌面上的应用文件夹来比喻。套件本身不包含任何业务逻辑，没有应用的套件是无法发布的。套件主要涉及的是钉钉企业认证、授权部分，所以也可将套件理解为钉钉的最小授权单位。套件也是钉钉的最小发布单位。当套件被企业授权后，企业钉钉内部将出现套件入口，企业内的员工就可以使用套件内的应用了。有意思的是，在发布套件出去的时候，可以指定套件内需要发布的应用，不一定要全部发布出去。\n\n### app\napp是钉钉应用的最小功能单位，本质上是一个H5应用，一个钉钉套件可以最多包含9个app（目前钉钉开发后台创建了app没法删除，这个需要注意一下）。从严格意义上看，授权过程实际上是将app与企业进行绑定（这个是钉钉后台干的事情）。然而在ISV里更常使用agent而不是app，这两个概念有一些细微差别。\n\n### agent\n在ISV接入中，app经过企业授权后，将以agent的形式出现。可以认为，app与企业经过绑定后，就变成了agent。实际上从功能的角度上看，agent就是app。\n\n### 免登\n免登的意思就是“免登陆”，有些操作需要登陆才有权限（例如拿到用户的身份信息，当然这里的登陆不是真的登陆，只是一种授权形式），如果不使用免登，则需要用户手动登陆授权，不是很友好，免登则可以解决这个问题。目前已知在钉钉开发过程中需要用到免登的大概有三种场景：1. 登陆钉钉用户账号 2. 登陆钉钉企业后台管理（SSO）。前者很常用，后者通常不会用到。而登陆钉钉用户账号其实又分为两种，一种是用户信息授权（只能拿到用户的手机号、工号等信息），另一种是获取用户操作权限（可以以用户的身份发消息等操作）。\n\n#### jsapi\n钉钉前端js接口，使用方式上与微信的JSSDK类似，但功能要强大得多。\n\n### 回调模式\n钉钉服务器主动向ISV服务器推送消息，这种行为模式被称作回调模式。前面所说的ISV接入的工作主要是就是与回调模式打交道。\n\n### 主动调用模式\nISV服务器除了被动接收钉钉服务器推送消息外，也可以主动向钉钉服务器发送请求。这种行为模式被称作主动调用模式。\n\n### saltUI\n钉钉开发的一套前端框架，除了提供一般前端框架抽象好的组件外，还具有类似页面过渡等高级效果，可以更好地模拟本地应用的效果。比较遗憾的是saltUI依赖钉钉SDK，因此只能用来开发钉钉应用。\n\n------\n\n## 需要注意的地方\n\n### 一定要持久化保存 suite_ticket\nsuite_ticket是万物之源，所有后续流程都直接或间接依赖suite_ticket。suite_ticket的有效时间是20分钟，钉钉服务器会每20分钟推送一次最新的suite_ticket，这个是开发者不可控的。因此suite_ticket一定要持久化保存。此外，钉钉如果没有收到suite_ticket推送的响应，最多推送100次后就会停止推送。所以如果你的服务器宕机比较久，重启以后需要手动去ISV开发后台重启推送。这个挺容易理解，就是有时候会忘掉。\n\n### 企业授权认证注意实现容错机制\n钉钉文档中警告我们，如果认证过程没有正常完成，比如弄丢了临时授权码或永久授权码，那企业是无法正常使用钉钉应用的，而且也无法再次授权（会提示已授权）。所以，我们需要做好容错机制，比如持久化保存临时授权码，这样如果宕机不至于丢失。\n不过这个问题倒也不是非常严重，因为企业本身可以通过取消授权、再次授权的方式重启授权过程。\n\n### 谨慎生成线下部署二维码\n开发好的ISV应用有两种发布方式：线上（上架钉钉市场）、线下（扫二维码授权安装）。这个二维码不是你想生成就生成的，跟创建套件一样，在创建过程中，钉钉服务器会对应用进行功能验证（推送一些消息，看能否正常返回），如果有错误是生成不了二维码的。\n这里有一个非常坑的地方，生成线下部署二维码的时候，钉钉主要验证你是否实现了企业授权流程。它会先用一个测试企业向你发起授权，然后你需要保存好授权得到的永久授权码。如果不小心把永久授权码弄丢了，验证过程将永远无法通过，你也就永远别想生成线二维码了。唯一的解决办法是去找钉钉工作人员手动给你解除授权。\n\n### 本地测试记得改套件配置\n钉钉本地调试还是比较友好的，只要你的机器可以被外网访问就行。但在本地测试前记得修改钉钉套件的回调url以及套件内应用的首页地址。有时候这些配置还会写在代码的config文件里，所以那里面也要记得修改。这个过程稍微有些麻烦，但还可以接受。\n\n### 钉钉应用入口是唯一可以凭空获取corpId的地方\n只有点击钉钉应用进入页面的方式才能获取到corpId，其他打开方式例如直接打开应用内页面链接是无法拿到corpId的。而只有拿到corpId，才可以一步步拿到最终的钉钉用户id，所以corpId非常重要。这就引出一个问题，如果就是想通过链接打开钉钉应用页面呢？（比如一个带链接的通知）没有别的办法，只能在链接中附带上corpId的信息（或者用token屏蔽一次）。有时候为了方便，甚至直接把获取到的钉钉用户id也放在url的query部分了，看着像是把内裤穿在外面，确实欠妥但简单粗暴有效。\n\n### chrome远程调试谁用谁知道\n钉钉Android开发者版本可以借助chrome远程调试，非常好用。iOS版则有些鸡肋，只能安装在虚拟机上。要知道有些问题必须在真机上才能发现，所以还是推荐Android版本。\n\n### js文件不能过大\n钉钉文档中没有明说，但根据钉钉开发人员的建议，单个js文件最好不要超过1MB，否则钉钉会拒绝加载。这个限制对于习惯了webpack hmr的开发者来说非常蛋疼，因为webpack打包好的bundle随随便便就超过1MB了。要么对webpack打包进行优化，比如拆分、动态加载之类的，要么就放弃hmr，每次都打包成minified的版本。\n","slug":"dingding-isv-development-tips","published":1,"updated":"2016-08-30T15:37:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkg0007u9yyj0eg0ff1","content":"<h2 id=\"钉钉开发大致分为以下几个部分\"><a href=\"#钉钉开发大致分为以下几个部分\" class=\"headerlink\" title=\"钉钉开发大致分为以下几个部分\"></a>钉钉开发大致分为以下几个部分</h2><ol>\n<li>接入</li>\n<li>服务端开发</li>\n<li>桌面端开发</li>\n<li>移动端开发</li>\n</ol>\n<hr>\n<h2 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h2><p>这里忽略正式接入之前的各种手续（注册开发账号、企业认证等等）</p>\n<p>接入的流程十分繁琐，这其中相当重要的一部分工作是做到正确响应钉钉服务器的推送消息。可以认为“接入”指的就是把架子搭起来，做到正确响应钉钉推送。钉钉认为，如果开发者连这个都做不到，就不应该准许你继续后面的开发工作（不给你创建套件）。而只有完成了基础框架，才能够创建开发套件，才算是入了门了。估计这就是叫“接入”的原因。</p>\n<p>钉钉服务器的推送看上去不多，也就7种，分为5类。必须正确相应所有的推送请求才算完。目前没有相应的node sdk，只能自己写。如果只是单纯为了响应请求（比如返回一个success）那是很容易的，复杂的地方在于一些推送之间存在关联关系，而要正确处理则往往涉及到数据持久化操作，所以很容易跟业务逻辑耦合起来。</p>\n<p>接入又分为企业接入和ISV接入两种。企业接入指的是开发企业专属的定制化钉钉应用，这个应用无法发布出去，只能在某一个企业内部使用。而ISV与前者的区别在于是可发布的，能够被不同企业安装使用。可以看出，SaaS公司通常都会选择ISV接入。企业接入由于无法发布，所以在接入流程上相比ISV接入要简化许多。</p>\n<p>钉钉官方文档中给的这个流程图非常好，看懂下面这张图，ISV的接入部分就没有问题了</p>\n<p><img src=\"https://img.alicdn.com/tps/TB1Fm1HJVXXXXXFaXXXXXXXXXXX-2376-1880.jpg\" alt=\"钉钉ISV接入流程\"></p>\n<p>最后，一句话总结，接入部分的工作就是做到能够正确相应钉钉服务器的推送。</p>\n<hr>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><p>由于不涉及到桌面端开发，所以这里只讲移动端和服务端。</p>\n<p>服务端的开发与普通web后端开发没什么不同，移动端开发无非是调用了一下钉钉专属的jsapi，也没有什么难点。唯一的困难是正确使用钉钉接口以及理解各种名词，下面只列举一些比较关键的概念。</p>\n<h3 id=\"suite\"><a href=\"#suite\" class=\"headerlink\" title=\"suite\"></a>suite</h3><p>钉钉应用的开发是以套件为单位的。套件是一组应用的容器，可以用手机桌面上的应用文件夹来比喻。套件本身不包含任何业务逻辑，没有应用的套件是无法发布的。套件主要涉及的是钉钉企业认证、授权部分，所以也可将套件理解为钉钉的最小授权单位。套件也是钉钉的最小发布单位。当套件被企业授权后，企业钉钉内部将出现套件入口，企业内的员工就可以使用套件内的应用了。有意思的是，在发布套件出去的时候，可以指定套件内需要发布的应用，不一定要全部发布出去。</p>\n<h3 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h3><p>app是钉钉应用的最小功能单位，本质上是一个H5应用，一个钉钉套件可以最多包含9个app（目前钉钉开发后台创建了app没法删除，这个需要注意一下）。从严格意义上看，授权过程实际上是将app与企业进行绑定（这个是钉钉后台干的事情）。然而在ISV里更常使用agent而不是app，这两个概念有一些细微差别。</p>\n<h3 id=\"agent\"><a href=\"#agent\" class=\"headerlink\" title=\"agent\"></a>agent</h3><p>在ISV接入中，app经过企业授权后，将以agent的形式出现。可以认为，app与企业经过绑定后，就变成了agent。实际上从功能的角度上看，agent就是app。</p>\n<h3 id=\"免登\"><a href=\"#免登\" class=\"headerlink\" title=\"免登\"></a>免登</h3><p>免登的意思就是“免登陆”，有些操作需要登陆才有权限（例如拿到用户的身份信息，当然这里的登陆不是真的登陆，只是一种授权形式），如果不使用免登，则需要用户手动登陆授权，不是很友好，免登则可以解决这个问题。目前已知在钉钉开发过程中需要用到免登的大概有三种场景：1. 登陆钉钉用户账号 2. 登陆钉钉企业后台管理（SSO）。前者很常用，后者通常不会用到。而登陆钉钉用户账号其实又分为两种，一种是用户信息授权（只能拿到用户的手机号、工号等信息），另一种是获取用户操作权限（可以以用户的身份发消息等操作）。</p>\n<h4 id=\"jsapi\"><a href=\"#jsapi\" class=\"headerlink\" title=\"jsapi\"></a>jsapi</h4><p>钉钉前端js接口，使用方式上与微信的JSSDK类似，但功能要强大得多。</p>\n<h3 id=\"回调模式\"><a href=\"#回调模式\" class=\"headerlink\" title=\"回调模式\"></a>回调模式</h3><p>钉钉服务器主动向ISV服务器推送消息，这种行为模式被称作回调模式。前面所说的ISV接入的工作主要是就是与回调模式打交道。</p>\n<h3 id=\"主动调用模式\"><a href=\"#主动调用模式\" class=\"headerlink\" title=\"主动调用模式\"></a>主动调用模式</h3><p>ISV服务器除了被动接收钉钉服务器推送消息外，也可以主动向钉钉服务器发送请求。这种行为模式被称作主动调用模式。</p>\n<h3 id=\"saltUI\"><a href=\"#saltUI\" class=\"headerlink\" title=\"saltUI\"></a>saltUI</h3><p>钉钉开发的一套前端框架，除了提供一般前端框架抽象好的组件外，还具有类似页面过渡等高级效果，可以更好地模拟本地应用的效果。比较遗憾的是saltUI依赖钉钉SDK，因此只能用来开发钉钉应用。</p>\n<hr>\n<h2 id=\"需要注意的地方\"><a href=\"#需要注意的地方\" class=\"headerlink\" title=\"需要注意的地方\"></a>需要注意的地方</h2><h3 id=\"一定要持久化保存-suite-ticket\"><a href=\"#一定要持久化保存-suite-ticket\" class=\"headerlink\" title=\"一定要持久化保存 suite_ticket\"></a>一定要持久化保存 suite_ticket</h3><p>suite_ticket是万物之源，所有后续流程都直接或间接依赖suite_ticket。suite_ticket的有效时间是20分钟，钉钉服务器会每20分钟推送一次最新的suite_ticket，这个是开发者不可控的。因此suite_ticket一定要持久化保存。此外，钉钉如果没有收到suite_ticket推送的响应，最多推送100次后就会停止推送。所以如果你的服务器宕机比较久，重启以后需要手动去ISV开发后台重启推送。这个挺容易理解，就是有时候会忘掉。</p>\n<h3 id=\"企业授权认证注意实现容错机制\"><a href=\"#企业授权认证注意实现容错机制\" class=\"headerlink\" title=\"企业授权认证注意实现容错机制\"></a>企业授权认证注意实现容错机制</h3><p>钉钉文档中警告我们，如果认证过程没有正常完成，比如弄丢了临时授权码或永久授权码，那企业是无法正常使用钉钉应用的，而且也无法再次授权（会提示已授权）。所以，我们需要做好容错机制，比如持久化保存临时授权码，这样如果宕机不至于丢失。<br>不过这个问题倒也不是非常严重，因为企业本身可以通过取消授权、再次授权的方式重启授权过程。</p>\n<h3 id=\"谨慎生成线下部署二维码\"><a href=\"#谨慎生成线下部署二维码\" class=\"headerlink\" title=\"谨慎生成线下部署二维码\"></a>谨慎生成线下部署二维码</h3><p>开发好的ISV应用有两种发布方式：线上（上架钉钉市场）、线下（扫二维码授权安装）。这个二维码不是你想生成就生成的，跟创建套件一样，在创建过程中，钉钉服务器会对应用进行功能验证（推送一些消息，看能否正常返回），如果有错误是生成不了二维码的。<br>这里有一个非常坑的地方，生成线下部署二维码的时候，钉钉主要验证你是否实现了企业授权流程。它会先用一个测试企业向你发起授权，然后你需要保存好授权得到的永久授权码。如果不小心把永久授权码弄丢了，验证过程将永远无法通过，你也就永远别想生成线二维码了。唯一的解决办法是去找钉钉工作人员手动给你解除授权。</p>\n<h3 id=\"本地测试记得改套件配置\"><a href=\"#本地测试记得改套件配置\" class=\"headerlink\" title=\"本地测试记得改套件配置\"></a>本地测试记得改套件配置</h3><p>钉钉本地调试还是比较友好的，只要你的机器可以被外网访问就行。但在本地测试前记得修改钉钉套件的回调url以及套件内应用的首页地址。有时候这些配置还会写在代码的config文件里，所以那里面也要记得修改。这个过程稍微有些麻烦，但还可以接受。</p>\n<h3 id=\"钉钉应用入口是唯一可以凭空获取corpId的地方\"><a href=\"#钉钉应用入口是唯一可以凭空获取corpId的地方\" class=\"headerlink\" title=\"钉钉应用入口是唯一可以凭空获取corpId的地方\"></a>钉钉应用入口是唯一可以凭空获取corpId的地方</h3><p>只有点击钉钉应用进入页面的方式才能获取到corpId，其他打开方式例如直接打开应用内页面链接是无法拿到corpId的。而只有拿到corpId，才可以一步步拿到最终的钉钉用户id，所以corpId非常重要。这就引出一个问题，如果就是想通过链接打开钉钉应用页面呢？（比如一个带链接的通知）没有别的办法，只能在链接中附带上corpId的信息（或者用token屏蔽一次）。有时候为了方便，甚至直接把获取到的钉钉用户id也放在url的query部分了，看着像是把内裤穿在外面，确实欠妥但简单粗暴有效。</p>\n<h3 id=\"chrome远程调试谁用谁知道\"><a href=\"#chrome远程调试谁用谁知道\" class=\"headerlink\" title=\"chrome远程调试谁用谁知道\"></a>chrome远程调试谁用谁知道</h3><p>钉钉Android开发者版本可以借助chrome远程调试，非常好用。iOS版则有些鸡肋，只能安装在虚拟机上。要知道有些问题必须在真机上才能发现，所以还是推荐Android版本。</p>\n<h3 id=\"js文件不能过大\"><a href=\"#js文件不能过大\" class=\"headerlink\" title=\"js文件不能过大\"></a>js文件不能过大</h3><p>钉钉文档中没有明说，但根据钉钉开发人员的建议，单个js文件最好不要超过1MB，否则钉钉会拒绝加载。这个限制对于习惯了webpack hmr的开发者来说非常蛋疼，因为webpack打包好的bundle随随便便就超过1MB了。要么对webpack打包进行优化，比如拆分、动态加载之类的，要么就放弃hmr，每次都打包成minified的版本。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"钉钉开发大致分为以下几个部分\"><a href=\"#钉钉开发大致分为以下几个部分\" class=\"headerlink\" title=\"钉钉开发大致分为以下几个部分\"></a>钉钉开发大致分为以下几个部分</h2><ol>\n<li>接入</li>\n<li>服务端开发</li>\n<li>桌面端开发</li>\n<li>移动端开发</li>\n</ol>\n<hr>\n<h2 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h2><p>这里忽略正式接入之前的各种手续（注册开发账号、企业认证等等）</p>\n<p>接入的流程十分繁琐，这其中相当重要的一部分工作是做到正确响应钉钉服务器的推送消息。可以认为“接入”指的就是把架子搭起来，做到正确响应钉钉推送。钉钉认为，如果开发者连这个都做不到，就不应该准许你继续后面的开发工作（不给你创建套件）。而只有完成了基础框架，才能够创建开发套件，才算是入了门了。估计这就是叫“接入”的原因。</p>\n<p>钉钉服务器的推送看上去不多，也就7种，分为5类。必须正确相应所有的推送请求才算完。目前没有相应的node sdk，只能自己写。如果只是单纯为了响应请求（比如返回一个success）那是很容易的，复杂的地方在于一些推送之间存在关联关系，而要正确处理则往往涉及到数据持久化操作，所以很容易跟业务逻辑耦合起来。</p>\n<p>接入又分为企业接入和ISV接入两种。企业接入指的是开发企业专属的定制化钉钉应用，这个应用无法发布出去，只能在某一个企业内部使用。而ISV与前者的区别在于是可发布的，能够被不同企业安装使用。可以看出，SaaS公司通常都会选择ISV接入。企业接入由于无法发布，所以在接入流程上相比ISV接入要简化许多。</p>\n<p>钉钉官方文档中给的这个流程图非常好，看懂下面这张图，ISV的接入部分就没有问题了</p>\n<p><img src=\"https://img.alicdn.com/tps/TB1Fm1HJVXXXXXFaXXXXXXXXXXX-2376-1880.jpg\" alt=\"钉钉ISV接入流程\"></p>\n<p>最后，一句话总结，接入部分的工作就是做到能够正确相应钉钉服务器的推送。</p>\n<hr>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><p>由于不涉及到桌面端开发，所以这里只讲移动端和服务端。</p>\n<p>服务端的开发与普通web后端开发没什么不同，移动端开发无非是调用了一下钉钉专属的jsapi，也没有什么难点。唯一的困难是正确使用钉钉接口以及理解各种名词，下面只列举一些比较关键的概念。</p>\n<h3 id=\"suite\"><a href=\"#suite\" class=\"headerlink\" title=\"suite\"></a>suite</h3><p>钉钉应用的开发是以套件为单位的。套件是一组应用的容器，可以用手机桌面上的应用文件夹来比喻。套件本身不包含任何业务逻辑，没有应用的套件是无法发布的。套件主要涉及的是钉钉企业认证、授权部分，所以也可将套件理解为钉钉的最小授权单位。套件也是钉钉的最小发布单位。当套件被企业授权后，企业钉钉内部将出现套件入口，企业内的员工就可以使用套件内的应用了。有意思的是，在发布套件出去的时候，可以指定套件内需要发布的应用，不一定要全部发布出去。</p>\n<h3 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h3><p>app是钉钉应用的最小功能单位，本质上是一个H5应用，一个钉钉套件可以最多包含9个app（目前钉钉开发后台创建了app没法删除，这个需要注意一下）。从严格意义上看，授权过程实际上是将app与企业进行绑定（这个是钉钉后台干的事情）。然而在ISV里更常使用agent而不是app，这两个概念有一些细微差别。</p>\n<h3 id=\"agent\"><a href=\"#agent\" class=\"headerlink\" title=\"agent\"></a>agent</h3><p>在ISV接入中，app经过企业授权后，将以agent的形式出现。可以认为，app与企业经过绑定后，就变成了agent。实际上从功能的角度上看，agent就是app。</p>\n<h3 id=\"免登\"><a href=\"#免登\" class=\"headerlink\" title=\"免登\"></a>免登</h3><p>免登的意思就是“免登陆”，有些操作需要登陆才有权限（例如拿到用户的身份信息，当然这里的登陆不是真的登陆，只是一种授权形式），如果不使用免登，则需要用户手动登陆授权，不是很友好，免登则可以解决这个问题。目前已知在钉钉开发过程中需要用到免登的大概有三种场景：1. 登陆钉钉用户账号 2. 登陆钉钉企业后台管理（SSO）。前者很常用，后者通常不会用到。而登陆钉钉用户账号其实又分为两种，一种是用户信息授权（只能拿到用户的手机号、工号等信息），另一种是获取用户操作权限（可以以用户的身份发消息等操作）。</p>\n<h4 id=\"jsapi\"><a href=\"#jsapi\" class=\"headerlink\" title=\"jsapi\"></a>jsapi</h4><p>钉钉前端js接口，使用方式上与微信的JSSDK类似，但功能要强大得多。</p>\n<h3 id=\"回调模式\"><a href=\"#回调模式\" class=\"headerlink\" title=\"回调模式\"></a>回调模式</h3><p>钉钉服务器主动向ISV服务器推送消息，这种行为模式被称作回调模式。前面所说的ISV接入的工作主要是就是与回调模式打交道。</p>\n<h3 id=\"主动调用模式\"><a href=\"#主动调用模式\" class=\"headerlink\" title=\"主动调用模式\"></a>主动调用模式</h3><p>ISV服务器除了被动接收钉钉服务器推送消息外，也可以主动向钉钉服务器发送请求。这种行为模式被称作主动调用模式。</p>\n<h3 id=\"saltUI\"><a href=\"#saltUI\" class=\"headerlink\" title=\"saltUI\"></a>saltUI</h3><p>钉钉开发的一套前端框架，除了提供一般前端框架抽象好的组件外，还具有类似页面过渡等高级效果，可以更好地模拟本地应用的效果。比较遗憾的是saltUI依赖钉钉SDK，因此只能用来开发钉钉应用。</p>\n<hr>\n<h2 id=\"需要注意的地方\"><a href=\"#需要注意的地方\" class=\"headerlink\" title=\"需要注意的地方\"></a>需要注意的地方</h2><h3 id=\"一定要持久化保存-suite-ticket\"><a href=\"#一定要持久化保存-suite-ticket\" class=\"headerlink\" title=\"一定要持久化保存 suite_ticket\"></a>一定要持久化保存 suite_ticket</h3><p>suite_ticket是万物之源，所有后续流程都直接或间接依赖suite_ticket。suite_ticket的有效时间是20分钟，钉钉服务器会每20分钟推送一次最新的suite_ticket，这个是开发者不可控的。因此suite_ticket一定要持久化保存。此外，钉钉如果没有收到suite_ticket推送的响应，最多推送100次后就会停止推送。所以如果你的服务器宕机比较久，重启以后需要手动去ISV开发后台重启推送。这个挺容易理解，就是有时候会忘掉。</p>\n<h3 id=\"企业授权认证注意实现容错机制\"><a href=\"#企业授权认证注意实现容错机制\" class=\"headerlink\" title=\"企业授权认证注意实现容错机制\"></a>企业授权认证注意实现容错机制</h3><p>钉钉文档中警告我们，如果认证过程没有正常完成，比如弄丢了临时授权码或永久授权码，那企业是无法正常使用钉钉应用的，而且也无法再次授权（会提示已授权）。所以，我们需要做好容错机制，比如持久化保存临时授权码，这样如果宕机不至于丢失。<br>不过这个问题倒也不是非常严重，因为企业本身可以通过取消授权、再次授权的方式重启授权过程。</p>\n<h3 id=\"谨慎生成线下部署二维码\"><a href=\"#谨慎生成线下部署二维码\" class=\"headerlink\" title=\"谨慎生成线下部署二维码\"></a>谨慎生成线下部署二维码</h3><p>开发好的ISV应用有两种发布方式：线上（上架钉钉市场）、线下（扫二维码授权安装）。这个二维码不是你想生成就生成的，跟创建套件一样，在创建过程中，钉钉服务器会对应用进行功能验证（推送一些消息，看能否正常返回），如果有错误是生成不了二维码的。<br>这里有一个非常坑的地方，生成线下部署二维码的时候，钉钉主要验证你是否实现了企业授权流程。它会先用一个测试企业向你发起授权，然后你需要保存好授权得到的永久授权码。如果不小心把永久授权码弄丢了，验证过程将永远无法通过，你也就永远别想生成线二维码了。唯一的解决办法是去找钉钉工作人员手动给你解除授权。</p>\n<h3 id=\"本地测试记得改套件配置\"><a href=\"#本地测试记得改套件配置\" class=\"headerlink\" title=\"本地测试记得改套件配置\"></a>本地测试记得改套件配置</h3><p>钉钉本地调试还是比较友好的，只要你的机器可以被外网访问就行。但在本地测试前记得修改钉钉套件的回调url以及套件内应用的首页地址。有时候这些配置还会写在代码的config文件里，所以那里面也要记得修改。这个过程稍微有些麻烦，但还可以接受。</p>\n<h3 id=\"钉钉应用入口是唯一可以凭空获取corpId的地方\"><a href=\"#钉钉应用入口是唯一可以凭空获取corpId的地方\" class=\"headerlink\" title=\"钉钉应用入口是唯一可以凭空获取corpId的地方\"></a>钉钉应用入口是唯一可以凭空获取corpId的地方</h3><p>只有点击钉钉应用进入页面的方式才能获取到corpId，其他打开方式例如直接打开应用内页面链接是无法拿到corpId的。而只有拿到corpId，才可以一步步拿到最终的钉钉用户id，所以corpId非常重要。这就引出一个问题，如果就是想通过链接打开钉钉应用页面呢？（比如一个带链接的通知）没有别的办法，只能在链接中附带上corpId的信息（或者用token屏蔽一次）。有时候为了方便，甚至直接把获取到的钉钉用户id也放在url的query部分了，看着像是把内裤穿在外面，确实欠妥但简单粗暴有效。</p>\n<h3 id=\"chrome远程调试谁用谁知道\"><a href=\"#chrome远程调试谁用谁知道\" class=\"headerlink\" title=\"chrome远程调试谁用谁知道\"></a>chrome远程调试谁用谁知道</h3><p>钉钉Android开发者版本可以借助chrome远程调试，非常好用。iOS版则有些鸡肋，只能安装在虚拟机上。要知道有些问题必须在真机上才能发现，所以还是推荐Android版本。</p>\n<h3 id=\"js文件不能过大\"><a href=\"#js文件不能过大\" class=\"headerlink\" title=\"js文件不能过大\"></a>js文件不能过大</h3><p>钉钉文档中没有明说，但根据钉钉开发人员的建议，单个js文件最好不要超过1MB，否则钉钉会拒绝加载。这个限制对于习惯了webpack hmr的开发者来说非常蛋疼，因为webpack打包好的bundle随随便便就超过1MB了。要么对webpack打包进行优化，比如拆分、动态加载之类的，要么就放弃hmr，每次都打包成minified的版本。</p>\n"},{"title":"Meteor七牛客户端上传的例子","date":"2016-02-01T08:44:53.000Z","_content":"\n## 准备工作\n\n1. 安装七牛 nodejs SDK\n\n  因为 Meteor 无法使用原生 npm 包，必须借助 [meteorhacks](https://github.com/meteorhacks/npm) 才能使用，所以确保已经安装了 meteorhacks 。\n\n  首先安装 meteorhacks\n\n  `meteor add meteorhacks:npm`\n\n  然后在项目根路径下编辑 packages.json 文件，增加七牛的 node SDK\n\n  ```\n  {\n    \"qiniu\": \"6.1.9\"\n  }\n  ```\n\n  完成后重启 meteor 服务器即可\n\n  `meteor`\n\n  > 偶尔 meteorhacks 会出现无法正确加载 node modules 的问题，如果是这样尝试先卸载 meteorhacks 然后重新安装。\n\n2. 安装七牛 js SDK\n\n  > 前面安装的 nodejs SDK 是后端依赖，现在安装的 js SDK 是前端依赖，二者不要搞混了。\n\n  根据七牛文档说明，需要下载两个东西：plupload 和 七牛的 js SDK，下载后放在相应的路径下（比如 public ）然后让 index.html 引入即可。\n\n3. 安装 Meteor iron router\n\n  因为七牛上传需要服务器端和前端配合，需要配置好路由，所以要安装 [iron router](https://github.com/iron-meteor/iron-router)\n\n  `meteor add iron:router`\n\n## 七牛上传流程\n\n首先再回顾一下七牛官方教程中提到的文件上传流程\n\n{% asset_img qiniu-upload-flow.png 七牛上传流程 %}\n\n> 业务服务器指的是 Meteor 所在服务器\n\n其中，步骤 1 和 2 需要借助前面安装的七牛 nodejs SDK 实现，而步骤 3 和 4 则需要借助 js SDK实现。\n\n## 服务器端\n\n首先从服务器端开始，其实要做的就一件事：响应 token 请求\n\n利用 iron router，配置好相应路由 method\n\n```javascript\nconst qiniu = Meteor.npmRequire('qiniu');\nqiniu.conf.ACCESS_KEY = '你的 ACCESS_KEY';\nqiniu.conf.SECRET_KEY = '你的 SECRET_KEY';\n\nRouter.route('/api/uptoken', { where: 'server' })\n.get(function() {\n  const res = this.response;\n  const token = new qiniu.rs.PutPolicy('你的bucket名字');\n\n  res.statusCode = 200;\n  res.end(JSON.stringify({ uptoken: token }));\n});\n```\n\n这样，前端就可以通过向 '/api/uptoken' 这个 url 请求 upload token 了\n\n当然，这里只是出于演示的目的，简化了 token 的生成过程。具体的细节请参考七牛的 [nodejs SDK 文档](http://developer.qiniu.com/docs/v6/sdk/nodejs-sdk.html)\n\n## 客户端\n\n客户端有两件事要做\n\n1. 向后端请求 upload token\n\n  只需要向之前定义的 url 发送 GET 请求即可。方法有很多种，这里就不罗嗦了。\n\n2. 拿着 upload token 向七牛服务器上传文件\n\n  这里要用到七牛的 js SDK。因为只是演示，所以就直接复制 js SDK 文档上的代码了。\n\n  别忘了在 html 页面中放置一个 id 为 pickfiles 的 button ，而且其父容器 id 为 container。这是 plupload 所需要的，你也可以在 SDK 的配置中自定义 id 。\n\n```javascript\nQiniu.uploader({\n  runtimes: 'html5,html4',          //上传模式,依次退化\n  browse_button: 'pickfiles',       //上传选择的点选按钮，**必需**\n  uptoken_url: '/api/uptoken',      //Ajax请求upToken的Url，**强烈建议设置**（服务端提供）\n  domain: 'http://你的七牛域名',      //bucket 域名，下载资源时用到，**必需**\n  get_new_uptoken: false,           //设置上传文件的时候是否每次都重新获取新的token\n  container: 'container',           //上传区域DOM ID，默认是browser_button的父元素，\n  max_file_size: '100mb',           //最大文件体积限制\n  max_retries: 3,                   //上传失败最大重试次数\n  dragdrop: true,                   //开启可拖曳上传\n  drop_element: 'container',        //拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传\n  chunk_size: '4mb',                //分块上传时，每片的体积\n  auto_start: true,                 //选择文件后自动上传，若关闭需要自己绑定事件触发上传,\n  init: {\n    FilesAdded: function(up, files) {\n      plupload.each(files, function(file) {\n        // 文件添加进队列后,处理相关的事情\n      });\n    },\n    BeforeUpload: function(up, file) {\n      // 每个文件上传前,处理相关的事情\n    },\n    UploadProgress: function(up, file) {\n      // 每个文件上传时,处理相关的事情\n    },\n    FileUploaded: function(up, file, info) {\n      // 每个文件上传成功后,处理相关的事情\n      // 其中 info 是文件上传成功后，服务端返回的json，形式如\n      // {\n      //    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",\n      //    \"key\": \"gogopher.jpg\"\n      //  }\n      // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html\n\n      // var domain = up.getOption('domain');\n      // var res = parseJSON(info);\n      // var sourceLink = domain + res.key; 获取上传成功后的文件的Url\n    },\n    Error: function(up, err, errTip) {\n      // 上传出错时,处理相关的事情\n    },\n    UploadComplete: function() {\n      //队列文件处理完毕后,处理相关的事情\n    },\n    Key: function(up, file) {\n      // 若想在前端对每个文件的key进行个性化处理，可以配置该函数\n      // 该配置必须要在 unique_names: false , save_key: false 时才生效\n\n      var key = \"\";\n      // do something with key here\n      return key\n    },\n  },\n});\n```\n\n## 大功告成！\n\n作完上面的工作后，你就可以上传文件了，赶紧试试吧\n","source":"_posts/meteor-qiniu-client-upload-example.md","raw":"title: 'Meteor七牛客户端上传的例子'\ndate: 2016-02-01 16:44:53\ntags:\n---\n\n## 准备工作\n\n1. 安装七牛 nodejs SDK\n\n  因为 Meteor 无法使用原生 npm 包，必须借助 [meteorhacks](https://github.com/meteorhacks/npm) 才能使用，所以确保已经安装了 meteorhacks 。\n\n  首先安装 meteorhacks\n\n  `meteor add meteorhacks:npm`\n\n  然后在项目根路径下编辑 packages.json 文件，增加七牛的 node SDK\n\n  ```\n  {\n    \"qiniu\": \"6.1.9\"\n  }\n  ```\n\n  完成后重启 meteor 服务器即可\n\n  `meteor`\n\n  > 偶尔 meteorhacks 会出现无法正确加载 node modules 的问题，如果是这样尝试先卸载 meteorhacks 然后重新安装。\n\n2. 安装七牛 js SDK\n\n  > 前面安装的 nodejs SDK 是后端依赖，现在安装的 js SDK 是前端依赖，二者不要搞混了。\n\n  根据七牛文档说明，需要下载两个东西：plupload 和 七牛的 js SDK，下载后放在相应的路径下（比如 public ）然后让 index.html 引入即可。\n\n3. 安装 Meteor iron router\n\n  因为七牛上传需要服务器端和前端配合，需要配置好路由，所以要安装 [iron router](https://github.com/iron-meteor/iron-router)\n\n  `meteor add iron:router`\n\n## 七牛上传流程\n\n首先再回顾一下七牛官方教程中提到的文件上传流程\n\n{% asset_img qiniu-upload-flow.png 七牛上传流程 %}\n\n> 业务服务器指的是 Meteor 所在服务器\n\n其中，步骤 1 和 2 需要借助前面安装的七牛 nodejs SDK 实现，而步骤 3 和 4 则需要借助 js SDK实现。\n\n## 服务器端\n\n首先从服务器端开始，其实要做的就一件事：响应 token 请求\n\n利用 iron router，配置好相应路由 method\n\n```javascript\nconst qiniu = Meteor.npmRequire('qiniu');\nqiniu.conf.ACCESS_KEY = '你的 ACCESS_KEY';\nqiniu.conf.SECRET_KEY = '你的 SECRET_KEY';\n\nRouter.route('/api/uptoken', { where: 'server' })\n.get(function() {\n  const res = this.response;\n  const token = new qiniu.rs.PutPolicy('你的bucket名字');\n\n  res.statusCode = 200;\n  res.end(JSON.stringify({ uptoken: token }));\n});\n```\n\n这样，前端就可以通过向 '/api/uptoken' 这个 url 请求 upload token 了\n\n当然，这里只是出于演示的目的，简化了 token 的生成过程。具体的细节请参考七牛的 [nodejs SDK 文档](http://developer.qiniu.com/docs/v6/sdk/nodejs-sdk.html)\n\n## 客户端\n\n客户端有两件事要做\n\n1. 向后端请求 upload token\n\n  只需要向之前定义的 url 发送 GET 请求即可。方法有很多种，这里就不罗嗦了。\n\n2. 拿着 upload token 向七牛服务器上传文件\n\n  这里要用到七牛的 js SDK。因为只是演示，所以就直接复制 js SDK 文档上的代码了。\n\n  别忘了在 html 页面中放置一个 id 为 pickfiles 的 button ，而且其父容器 id 为 container。这是 plupload 所需要的，你也可以在 SDK 的配置中自定义 id 。\n\n```javascript\nQiniu.uploader({\n  runtimes: 'html5,html4',          //上传模式,依次退化\n  browse_button: 'pickfiles',       //上传选择的点选按钮，**必需**\n  uptoken_url: '/api/uptoken',      //Ajax请求upToken的Url，**强烈建议设置**（服务端提供）\n  domain: 'http://你的七牛域名',      //bucket 域名，下载资源时用到，**必需**\n  get_new_uptoken: false,           //设置上传文件的时候是否每次都重新获取新的token\n  container: 'container',           //上传区域DOM ID，默认是browser_button的父元素，\n  max_file_size: '100mb',           //最大文件体积限制\n  max_retries: 3,                   //上传失败最大重试次数\n  dragdrop: true,                   //开启可拖曳上传\n  drop_element: 'container',        //拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传\n  chunk_size: '4mb',                //分块上传时，每片的体积\n  auto_start: true,                 //选择文件后自动上传，若关闭需要自己绑定事件触发上传,\n  init: {\n    FilesAdded: function(up, files) {\n      plupload.each(files, function(file) {\n        // 文件添加进队列后,处理相关的事情\n      });\n    },\n    BeforeUpload: function(up, file) {\n      // 每个文件上传前,处理相关的事情\n    },\n    UploadProgress: function(up, file) {\n      // 每个文件上传时,处理相关的事情\n    },\n    FileUploaded: function(up, file, info) {\n      // 每个文件上传成功后,处理相关的事情\n      // 其中 info 是文件上传成功后，服务端返回的json，形式如\n      // {\n      //    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",\n      //    \"key\": \"gogopher.jpg\"\n      //  }\n      // 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html\n\n      // var domain = up.getOption('domain');\n      // var res = parseJSON(info);\n      // var sourceLink = domain + res.key; 获取上传成功后的文件的Url\n    },\n    Error: function(up, err, errTip) {\n      // 上传出错时,处理相关的事情\n    },\n    UploadComplete: function() {\n      //队列文件处理完毕后,处理相关的事情\n    },\n    Key: function(up, file) {\n      // 若想在前端对每个文件的key进行个性化处理，可以配置该函数\n      // 该配置必须要在 unique_names: false , save_key: false 时才生效\n\n      var key = \"\";\n      // do something with key here\n      return key\n    },\n  },\n});\n```\n\n## 大功告成！\n\n作完上面的工作后，你就可以上传文件了，赶紧试试吧\n","slug":"meteor-qiniu-client-upload-example","published":1,"updated":"2016-02-01T14:43:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkh0008u9yy1lxy8w1h","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li><p>安装七牛 nodejs SDK</p>\n<p>因为 Meteor 无法使用原生 npm 包，必须借助 <a href=\"https://github.com/meteorhacks/npm\" target=\"_blank\" rel=\"noopener\">meteorhacks</a> 才能使用，所以确保已经安装了 meteorhacks 。</p>\n<p>首先安装 meteorhacks</p>\n<p><code>meteor add meteorhacks:npm</code></p>\n<p>然后在项目根路径下编辑 packages.json 文件，增加七牛的 node SDK</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"qiniu\"</span>: <span class=\"string\">\"6.1.9\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成后重启 meteor 服务器即可</p>\n<p><code>meteor</code></p>\n<blockquote>\n<p>偶尔 meteorhacks 会出现无法正确加载 node modules 的问题，如果是这样尝试先卸载 meteorhacks 然后重新安装。</p>\n</blockquote>\n</li>\n<li><p>安装七牛 js SDK</p>\n<blockquote>\n<p>前面安装的 nodejs SDK 是后端依赖，现在安装的 js SDK 是前端依赖，二者不要搞混了。</p>\n</blockquote>\n<p>根据七牛文档说明，需要下载两个东西：plupload 和 七牛的 js SDK，下载后放在相应的路径下（比如 public ）然后让 index.html 引入即可。</p>\n</li>\n<li><p>安装 Meteor iron router</p>\n<p>因为七牛上传需要服务器端和前端配合，需要配置好路由，所以要安装 <a href=\"https://github.com/iron-meteor/iron-router\" target=\"_blank\" rel=\"noopener\">iron router</a></p>\n<p><code>meteor add iron:router</code></p>\n</li>\n</ol>\n<h2 id=\"七牛上传流程\"><a href=\"#七牛上传流程\" class=\"headerlink\" title=\"七牛上传流程\"></a>七牛上传流程</h2><p>首先再回顾一下七牛官方教程中提到的文件上传流程</p>\n<img src=\"/2016/02/01/meteor-qiniu-client-upload-example/qiniu-upload-flow.png\" title=\"七牛上传流程\">\n<blockquote>\n<p>业务服务器指的是 Meteor 所在服务器</p>\n</blockquote>\n<p>其中，步骤 1 和 2 需要借助前面安装的七牛 nodejs SDK 实现，而步骤 3 和 4 则需要借助 js SDK实现。</p>\n<h2 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h2><p>首先从服务器端开始，其实要做的就一件事：响应 token 请求</p>\n<p>利用 iron router，配置好相应路由 method</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> qiniu = Meteor.npmRequire(<span class=\"string\">'qiniu'</span>);</span><br><span class=\"line\">qiniu.conf.ACCESS_KEY = <span class=\"string\">'你的 ACCESS_KEY'</span>;</span><br><span class=\"line\">qiniu.conf.SECRET_KEY = <span class=\"string\">'你的 SECRET_KEY'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.route(<span class=\"string\">'/api/uptoken'</span>, &#123; <span class=\"attr\">where</span>: <span class=\"string\">'server'</span> &#125;)</span><br><span class=\"line\">.get(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">this</span>.response;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = <span class=\"keyword\">new</span> qiniu.rs.PutPolicy(<span class=\"string\">'你的bucket名字'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  res.statusCode = <span class=\"number\">200</span>;</span><br><span class=\"line\">  res.end(<span class=\"built_in\">JSON</span>.stringify(&#123; <span class=\"attr\">uptoken</span>: token &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样，前端就可以通过向 ‘/api/uptoken’ 这个 url 请求 upload token 了</p>\n<p>当然，这里只是出于演示的目的，简化了 token 的生成过程。具体的细节请参考七牛的 <a href=\"http://developer.qiniu.com/docs/v6/sdk/nodejs-sdk.html\" target=\"_blank\" rel=\"noopener\">nodejs SDK 文档</a></p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p>客户端有两件事要做</p>\n<ol>\n<li><p>向后端请求 upload token</p>\n<p>只需要向之前定义的 url 发送 GET 请求即可。方法有很多种，这里就不罗嗦了。</p>\n</li>\n<li><p>拿着 upload token 向七牛服务器上传文件</p>\n<p>这里要用到七牛的 js SDK。因为只是演示，所以就直接复制 js SDK 文档上的代码了。</p>\n<p>别忘了在 html 页面中放置一个 id 为 pickfiles 的 button ，而且其父容器 id 为 container。这是 plupload 所需要的，你也可以在 SDK 的配置中自定义 id 。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Qiniu.uploader(&#123;</span><br><span class=\"line\">  runtimes: <span class=\"string\">'html5,html4'</span>,          <span class=\"comment\">//上传模式,依次退化</span></span><br><span class=\"line\">  browse_button: <span class=\"string\">'pickfiles'</span>,       <span class=\"comment\">//上传选择的点选按钮，**必需**</span></span><br><span class=\"line\">  uptoken_url: <span class=\"string\">'/api/uptoken'</span>,      <span class=\"comment\">//Ajax请求upToken的Url，**强烈建议设置**（服务端提供）</span></span><br><span class=\"line\">  domain: <span class=\"string\">'http://你的七牛域名'</span>,      <span class=\"comment\">//bucket 域名，下载资源时用到，**必需**</span></span><br><span class=\"line\">  get_new_uptoken: <span class=\"literal\">false</span>,           <span class=\"comment\">//设置上传文件的时候是否每次都重新获取新的token</span></span><br><span class=\"line\">  container: <span class=\"string\">'container'</span>,           <span class=\"comment\">//上传区域DOM ID，默认是browser_button的父元素，</span></span><br><span class=\"line\">  max_file_size: <span class=\"string\">'100mb'</span>,           <span class=\"comment\">//最大文件体积限制</span></span><br><span class=\"line\">  max_retries: <span class=\"number\">3</span>,                   <span class=\"comment\">//上传失败最大重试次数</span></span><br><span class=\"line\">  dragdrop: <span class=\"literal\">true</span>,                   <span class=\"comment\">//开启可拖曳上传</span></span><br><span class=\"line\">  drop_element: <span class=\"string\">'container'</span>,        <span class=\"comment\">//拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传</span></span><br><span class=\"line\">  chunk_size: <span class=\"string\">'4mb'</span>,                <span class=\"comment\">//分块上传时，每片的体积</span></span><br><span class=\"line\">  auto_start: <span class=\"literal\">true</span>,                 <span class=\"comment\">//选择文件后自动上传，若关闭需要自己绑定事件触发上传,</span></span><br><span class=\"line\">  init: &#123;</span><br><span class=\"line\">    FilesAdded: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, files</span>) </span>&#123;</span><br><span class=\"line\">      plupload.each(files, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 文件添加进队列后,处理相关的事情</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    BeforeUpload: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 每个文件上传前,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UploadProgress: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 每个文件上传时,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    FileUploaded: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file, info</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 每个文件上传成功后,处理相关的事情</span></span><br><span class=\"line\">      <span class=\"comment\">// 其中 info 是文件上传成功后，服务端返回的json，形式如</span></span><br><span class=\"line\">      <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",</span></span><br><span class=\"line\">      <span class=\"comment\">//    \"key\": \"gogopher.jpg\"</span></span><br><span class=\"line\">      <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// var domain = up.getOption('domain');</span></span><br><span class=\"line\">      <span class=\"comment\">// var res = parseJSON(info);</span></span><br><span class=\"line\">      <span class=\"comment\">// var sourceLink = domain + res.key; 获取上传成功后的文件的Url</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">Error</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, err, errTip</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 上传出错时,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UploadComplete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//队列文件处理完毕后,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Key: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若想在前端对每个文件的key进行个性化处理，可以配置该函数</span></span><br><span class=\"line\">      <span class=\"comment\">// 该配置必须要在 unique_names: false , save_key: false 时才生效</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">      <span class=\"comment\">// do something with key here</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> key</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"大功告成！\"><a href=\"#大功告成！\" class=\"headerlink\" title=\"大功告成！\"></a>大功告成！</h2><p>作完上面的工作后，你就可以上传文件了，赶紧试试吧</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li><p>安装七牛 nodejs SDK</p>\n<p>因为 Meteor 无法使用原生 npm 包，必须借助 <a href=\"https://github.com/meteorhacks/npm\" target=\"_blank\" rel=\"noopener\">meteorhacks</a> 才能使用，所以确保已经安装了 meteorhacks 。</p>\n<p>首先安装 meteorhacks</p>\n<p><code>meteor add meteorhacks:npm</code></p>\n<p>然后在项目根路径下编辑 packages.json 文件，增加七牛的 node SDK</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"qiniu\"</span>: <span class=\"string\">\"6.1.9\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成后重启 meteor 服务器即可</p>\n<p><code>meteor</code></p>\n<blockquote>\n<p>偶尔 meteorhacks 会出现无法正确加载 node modules 的问题，如果是这样尝试先卸载 meteorhacks 然后重新安装。</p>\n</blockquote>\n</li>\n<li><p>安装七牛 js SDK</p>\n<blockquote>\n<p>前面安装的 nodejs SDK 是后端依赖，现在安装的 js SDK 是前端依赖，二者不要搞混了。</p>\n</blockquote>\n<p>根据七牛文档说明，需要下载两个东西：plupload 和 七牛的 js SDK，下载后放在相应的路径下（比如 public ）然后让 index.html 引入即可。</p>\n</li>\n<li><p>安装 Meteor iron router</p>\n<p>因为七牛上传需要服务器端和前端配合，需要配置好路由，所以要安装 <a href=\"https://github.com/iron-meteor/iron-router\" target=\"_blank\" rel=\"noopener\">iron router</a></p>\n<p><code>meteor add iron:router</code></p>\n</li>\n</ol>\n<h2 id=\"七牛上传流程\"><a href=\"#七牛上传流程\" class=\"headerlink\" title=\"七牛上传流程\"></a>七牛上传流程</h2><p>首先再回顾一下七牛官方教程中提到的文件上传流程</p>\n<img src=\"/2016/02/01/meteor-qiniu-client-upload-example/qiniu-upload-flow.png\" title=\"七牛上传流程\">\n<blockquote>\n<p>业务服务器指的是 Meteor 所在服务器</p>\n</blockquote>\n<p>其中，步骤 1 和 2 需要借助前面安装的七牛 nodejs SDK 实现，而步骤 3 和 4 则需要借助 js SDK实现。</p>\n<h2 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h2><p>首先从服务器端开始，其实要做的就一件事：响应 token 请求</p>\n<p>利用 iron router，配置好相应路由 method</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> qiniu = Meteor.npmRequire(<span class=\"string\">'qiniu'</span>);</span><br><span class=\"line\">qiniu.conf.ACCESS_KEY = <span class=\"string\">'你的 ACCESS_KEY'</span>;</span><br><span class=\"line\">qiniu.conf.SECRET_KEY = <span class=\"string\">'你的 SECRET_KEY'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.route(<span class=\"string\">'/api/uptoken'</span>, &#123; <span class=\"attr\">where</span>: <span class=\"string\">'server'</span> &#125;)</span><br><span class=\"line\">.get(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">this</span>.response;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = <span class=\"keyword\">new</span> qiniu.rs.PutPolicy(<span class=\"string\">'你的bucket名字'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  res.statusCode = <span class=\"number\">200</span>;</span><br><span class=\"line\">  res.end(<span class=\"built_in\">JSON</span>.stringify(&#123; <span class=\"attr\">uptoken</span>: token &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这样，前端就可以通过向 ‘/api/uptoken’ 这个 url 请求 upload token 了</p>\n<p>当然，这里只是出于演示的目的，简化了 token 的生成过程。具体的细节请参考七牛的 <a href=\"http://developer.qiniu.com/docs/v6/sdk/nodejs-sdk.html\" target=\"_blank\" rel=\"noopener\">nodejs SDK 文档</a></p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p>客户端有两件事要做</p>\n<ol>\n<li><p>向后端请求 upload token</p>\n<p>只需要向之前定义的 url 发送 GET 请求即可。方法有很多种，这里就不罗嗦了。</p>\n</li>\n<li><p>拿着 upload token 向七牛服务器上传文件</p>\n<p>这里要用到七牛的 js SDK。因为只是演示，所以就直接复制 js SDK 文档上的代码了。</p>\n<p>别忘了在 html 页面中放置一个 id 为 pickfiles 的 button ，而且其父容器 id 为 container。这是 plupload 所需要的，你也可以在 SDK 的配置中自定义 id 。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Qiniu.uploader(&#123;</span><br><span class=\"line\">  runtimes: <span class=\"string\">'html5,html4'</span>,          <span class=\"comment\">//上传模式,依次退化</span></span><br><span class=\"line\">  browse_button: <span class=\"string\">'pickfiles'</span>,       <span class=\"comment\">//上传选择的点选按钮，**必需**</span></span><br><span class=\"line\">  uptoken_url: <span class=\"string\">'/api/uptoken'</span>,      <span class=\"comment\">//Ajax请求upToken的Url，**强烈建议设置**（服务端提供）</span></span><br><span class=\"line\">  domain: <span class=\"string\">'http://你的七牛域名'</span>,      <span class=\"comment\">//bucket 域名，下载资源时用到，**必需**</span></span><br><span class=\"line\">  get_new_uptoken: <span class=\"literal\">false</span>,           <span class=\"comment\">//设置上传文件的时候是否每次都重新获取新的token</span></span><br><span class=\"line\">  container: <span class=\"string\">'container'</span>,           <span class=\"comment\">//上传区域DOM ID，默认是browser_button的父元素，</span></span><br><span class=\"line\">  max_file_size: <span class=\"string\">'100mb'</span>,           <span class=\"comment\">//最大文件体积限制</span></span><br><span class=\"line\">  max_retries: <span class=\"number\">3</span>,                   <span class=\"comment\">//上传失败最大重试次数</span></span><br><span class=\"line\">  dragdrop: <span class=\"literal\">true</span>,                   <span class=\"comment\">//开启可拖曳上传</span></span><br><span class=\"line\">  drop_element: <span class=\"string\">'container'</span>,        <span class=\"comment\">//拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传</span></span><br><span class=\"line\">  chunk_size: <span class=\"string\">'4mb'</span>,                <span class=\"comment\">//分块上传时，每片的体积</span></span><br><span class=\"line\">  auto_start: <span class=\"literal\">true</span>,                 <span class=\"comment\">//选择文件后自动上传，若关闭需要自己绑定事件触发上传,</span></span><br><span class=\"line\">  init: &#123;</span><br><span class=\"line\">    FilesAdded: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, files</span>) </span>&#123;</span><br><span class=\"line\">      plupload.each(files, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 文件添加进队列后,处理相关的事情</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    BeforeUpload: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 每个文件上传前,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UploadProgress: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 每个文件上传时,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    FileUploaded: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file, info</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 每个文件上传成功后,处理相关的事情</span></span><br><span class=\"line\">      <span class=\"comment\">// 其中 info 是文件上传成功后，服务端返回的json，形式如</span></span><br><span class=\"line\">      <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">      <span class=\"comment\">//    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",</span></span><br><span class=\"line\">      <span class=\"comment\">//    \"key\": \"gogopher.jpg\"</span></span><br><span class=\"line\">      <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// var domain = up.getOption('domain');</span></span><br><span class=\"line\">      <span class=\"comment\">// var res = parseJSON(info);</span></span><br><span class=\"line\">      <span class=\"comment\">// var sourceLink = domain + res.key; 获取上传成功后的文件的Url</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">Error</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, err, errTip</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 上传出错时,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UploadComplete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//队列文件处理完毕后,处理相关的事情</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Key: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若想在前端对每个文件的key进行个性化处理，可以配置该函数</span></span><br><span class=\"line\">      <span class=\"comment\">// 该配置必须要在 unique_names: false , save_key: false 时才生效</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">      <span class=\"comment\">// do something with key here</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> key</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"大功告成！\"><a href=\"#大功告成！\" class=\"headerlink\" title=\"大功告成！\"></a>大功告成！</h2><p>作完上面的工作后，你就可以上传文件了，赶紧试试吧</p>\n"},{"title":"学习计划","date":"2019-05-09T14:57:18.000Z","_content":"\n## 2019年\n\n### 5月 Babel\n\n- 系统JavaScript AST\n- flow graph和call graph的构造算法\n- 静态分析还能做什么\n\n### 6月 SpringBoot\n\n- 体验并上手SprintBoot,搭建开发环境,写点代码,部署\n- SpringBoot架构及原理,于Node开发的对比\n- Spring家族各种眼花缭乱名词儿都是什么含义\n- SpringCloud与微服务架构\n","source":"_posts/study-plan.md","raw":"---\ntitle: 学习计划\ndate: 2019-05-09 22:57:18\ntags:\n---\n\n## 2019年\n\n### 5月 Babel\n\n- 系统JavaScript AST\n- flow graph和call graph的构造算法\n- 静态分析还能做什么\n\n### 6月 SpringBoot\n\n- 体验并上手SprintBoot,搭建开发环境,写点代码,部署\n- SpringBoot架构及原理,于Node开发的对比\n- Spring家族各种眼花缭乱名词儿都是什么含义\n- SpringCloud与微服务架构\n","slug":"study-plan","published":1,"updated":"2019-05-10T02:36:49.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkk000bu9yyihtyjk75","content":"<h2 id=\"2019年\"><a href=\"#2019年\" class=\"headerlink\" title=\"2019年\"></a>2019年</h2><h3 id=\"5月-Babel\"><a href=\"#5月-Babel\" class=\"headerlink\" title=\"5月 Babel\"></a>5月 Babel</h3><ul>\n<li>系统JavaScript AST</li>\n<li>flow graph和call graph的构造算法</li>\n<li>静态分析还能做什么</li>\n</ul>\n<h3 id=\"6月-SpringBoot\"><a href=\"#6月-SpringBoot\" class=\"headerlink\" title=\"6月 SpringBoot\"></a>6月 SpringBoot</h3><ul>\n<li>体验并上手SprintBoot,搭建开发环境,写点代码,部署</li>\n<li>SpringBoot架构及原理,于Node开发的对比</li>\n<li>Spring家族各种眼花缭乱名词儿都是什么含义</li>\n<li>SpringCloud与微服务架构</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2019年\"><a href=\"#2019年\" class=\"headerlink\" title=\"2019年\"></a>2019年</h2><h3 id=\"5月-Babel\"><a href=\"#5月-Babel\" class=\"headerlink\" title=\"5月 Babel\"></a>5月 Babel</h3><ul>\n<li>系统JavaScript AST</li>\n<li>flow graph和call graph的构造算法</li>\n<li>静态分析还能做什么</li>\n</ul>\n<h3 id=\"6月-SpringBoot\"><a href=\"#6月-SpringBoot\" class=\"headerlink\" title=\"6月 SpringBoot\"></a>6月 SpringBoot</h3><ul>\n<li>体验并上手SprintBoot,搭建开发环境,写点代码,部署</li>\n<li>SpringBoot架构及原理,于Node开发的对比</li>\n<li>Spring家族各种眼花缭乱名词儿都是什么含义</li>\n<li>SpringCloud与微服务架构</li>\n</ul>\n"},{"title":"es6-proxy-and-reflect","_content":"\n为了更好地支持 meta-programming，ES6 新添加了 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 和 [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)。\n\n然而大部分情况下，你都不会用到他们。一方面是因为 meta-programming 本身并不是编程的必须要素，另一方面是因为 Proxy 和 Reflect 不过是**原型链继承**在特定场景下的语法糖而已。\n\n有些你想要**扩展**一个对象的行为，即在原有对象的行为基础上增加一些花样。比如你有一个\n\n\n","source":"_drafts/es6-proxy-and-reflect.md","raw":"title: es6-proxy-and-reflect\ntags: javascript\n---\n\n为了更好地支持 meta-programming，ES6 新添加了 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 和 [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)。\n\n然而大部分情况下，你都不会用到他们。一方面是因为 meta-programming 本身并不是编程的必须要素，另一方面是因为 Proxy 和 Reflect 不过是**原型链继承**在特定场景下的语法糖而已。\n\n有些你想要**扩展**一个对象的行为，即在原有对象的行为基础上增加一些花样。比如你有一个\n\n\n","slug":"es6-proxy-and-reflect","published":0,"date":"2016-03-27T15:31:35.000Z","updated":"2016-03-27T15:51:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkl000cu9yyh2w5j376","content":"<p>为了更好地支持 meta-programming，ES6 新添加了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"noopener\">Proxy</a> 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"noopener\">Reflect</a>。</p>\n<p>然而大部分情况下，你都不会用到他们。一方面是因为 meta-programming 本身并不是编程的必须要素，另一方面是因为 Proxy 和 Reflect 不过是<strong>原型链继承</strong>在特定场景下的语法糖而已。</p>\n<p>有些你想要<strong>扩展</strong>一个对象的行为，即在原有对象的行为基础上增加一些花样。比如你有一个</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了更好地支持 meta-programming，ES6 新添加了 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"noopener\">Proxy</a> 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\" target=\"_blank\" rel=\"noopener\">Reflect</a>。</p>\n<p>然而大部分情况下，你都不会用到他们。一方面是因为 meta-programming 本身并不是编程的必须要素，另一方面是因为 Proxy 和 Reflect 不过是<strong>原型链继承</strong>在特定场景下的语法糖而已。</p>\n<p>有些你想要<strong>扩展</strong>一个对象的行为，即在原有对象的行为基础上增加一些花样。比如你有一个</p>\n"},{"title":"从零开始搭建 Express + Vue 开发环境","date":"2016-02-28T06:02:16.000Z","_content":"\n完整的代码已经上传 Github，[点击访问](https://github.com/southerncross/vue-express-dev-boilerplate)\n\n## 准备工作\n\n### 1. 为前端选择合适的预处理工具和资源管理工具\n\n预处理工具又分为 js 预处理工具和 css 预处理工具。Javascript 一直以来最为人诟病的一点就是缺乏原生的模块机制，所有 js 代码文件在被 html 页面引入后将共用同一个命名空间。所以才出现了各种“标准”尝试解决这个问题，但他们都不是原生的，需要额外的工具对代码进行特殊处理。虽然 ES6 终于引入了模块机制，但以现在的浏览器支持程度，还不足以“毫无顾虑地随拿随用”。所以 js 预处理工具最主要的工作就是帮助解决 js 的模块问题。而 css 预处理工具则很好理解，就是把 sass，less 或者 stylus 代码翻译、合并成 css 代码。\n\n资源管理工具则是帮我们管理前端所需的各种资源文件（比如 css、js、图片、字体等等），便于我们引用。目前常用的解决方法是将他们直接编码进 js 代码中，然后像引用 js 模块一样引用它们。这可比手写各种 url 方便多了。\n\n正如标题所说，我们将采用 Webpack，因为它具备上面所说的所有功能。此外还支持代码热替换，使修改代码后不用刷新页面也能在浏览器中立即看到效果。\n\n![Webpack schedule](http://webpack.github.io/assets/what-is-webpack.png)\n\n### 2. 为后端选择合适的预处理工具\n\n后端面对的都是 js 代码，不需要前端那样的资源管理工具，另外， Node 强迫你使用至少一种模块管理方案（CommonJS 或 ES6 的 import），也不用考虑代码的依赖问题。\n\n所以后端要简单许多，唯一需要考虑的基本上就剩下如何将 ES6 转译成 ES5 了（如果你打算使用 ES6 的话）。目前常用的做法是使用 Babel，你可以用 Babel 命令行工具独立执行编译过程，也可以配置 Babel register 实现代码运行时动态翻译，这对于开发场景而言无疑是最方便的。所以我们选择后一种方式。\n\n![Babel logo](https://babeljs.io/images/logo.svg)\n\n### 3. 为整个项目选择合适的流程控制工具\n\n流程控制工具是为了帮助我们管理诸如代码检查、编译、压缩、移动、部署这些任务的，原本我们是通过手敲命令（或者高级一点写个脚本）的方式做，有了流程控制工具以后，只需要提供配置文件和少量代码就可以完成。\n\n目前最流行的解决方案是 gulp。不过，由于我们这里要搭建的是开发环境，没有移动代码、压缩、部署等需求，所以不需要功能强大的 gulp。我们只要用 nodemon 这个工具监听代码变动然后适时重启 server就够了。\n\n![Nodemon logo](https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667)\n\n## 正式开始搭建\n\n### 1. 利用 Express 脚手架快速搭建应用\n\n使用 Express 提供的脚手架工具（[Express application generator](http://expressjs.com/en/starter/generator.html)）可以在 1s 之内搭建出最基本的应用。\n\n如果你以前还没试过，首先执行下面的命令安装\n\n`npm install express-generator -g`\n\n然后执行以下命令生成代码，命令执行过程中需要输入一些参数。\n\n`express <myapp>`\n\n完成后的文件结构是这样的\n\n```\n.\n├── app.js\n├── bin\n│   └── www\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n```\n\n但是这个文件结构只是后端代码，要想跟前端代码相结合，需要做一些改动。我们计划最终的文件结构应该是这样的\n\n```\n.\n├── src\n│   ├── client\n│   └── server\n└── ...\n```\n\n所以需要将上面自动生成的 Express 代码放到 /src/server/ 路径下。\n\n接下来我们要删除一些用不着的东西以及增加一些缺失的东西。\n\n首先，由于我们打算在前端使用 Vue 框架，并由 Vue-Router 管理大部分路由，后端 Express 仅保留少量的 RESTful API 路由，所以后端不需要复杂的路由设置，那么 routes 文件夹下的内容可以简化成一个 routers.js 文件。\n\n然后，我们需要配置好 Babel register，所以需要在项目跟路径下新增两个文件 `.babelrc` 和 `index.js`，内容分别为：\n\n/.babelrc\n```json\n{\n  \"presets\": [\"es2015\"],\n}\n```\n.babelrc 是 Babel 6.0 必须的文件\n\n/.index.js\n```\nrequire('babel-register')\nrequire('./src/server')\n```\n上面两句完成 Bebel 注册，它会爬取所有 `require` 或 `import` 方式依赖的模块并把它们翻译成 ES5。\n\n自动生成的代码里有个 www 文件，他是 Express 应用的入口文件，我们把它放在 server 路径下并改名为 index.js 以便让上面配置的 Babel register 能正确找到它。\n\n> 为什么要改名为 index.js ？这是因为 `require('./src/server')` 在默认情况下会去找 ./src/server/index.js，如果你想用别的名字，那就记得将 Babel register 的配置文件里改为 `require(./src/<your entry file>`。\n\n好了，现在后端的事情先暂时告一段落，接下来看看前端。\n\n### 2. 利用 Vue 脚手架快速搭建应用\n\n同样地，推荐使用 Vue 自带的 [template 工具](https://github.com/vuejs-templates/webpack)，在 1s 内生成基本代码。\n\n虽然利用这个工具生成的代码的后端就是基于 Express 的，但是后端部分的代码结构太简单，不适合做后续开发。所以建议这里先将 Vue 生成的代码放在另外一个地方，然后按需移动到前面用 Express 生成的代码文件夹里。\n\n首先安装 template 工具\n\n`npm install -g vue-cli`\n\n然后执行命令生成代码。命令执行过程中需要输入一些参数\n\n`vue init webpack <my-project>`\n\n生成的代码结构是这样的\n\n```\n.\n├── build\n│   ├── dev-server.js         # development server script\n│   ├── karma.conf.js         # unit testing config\n│   ├── webpack.base.conf.js  # shared base webpack config\n│   ├── webpack.dev.conf.js   # development webpack config\n│   ├── webpack.prod.conf.js  # production webpack config\n│   └── ...\n├── src\n│   ├── main.js               # app entry file\n│   ├── App.vue               # main app component\n│   ├── components            # ui components\n│   │   └── ...\n│   └── assets                # module assets (processed by webpack)\n│       └── ...\n├── static                    # pure static assets (directly copied)\n├── dist                      # built files ready for deploy\n├── test\n│   └── unit                  # unit tests\n│       ├── index.js          # unit test entry file\n│       └── ...\n├── .babelrc                  # babel config\n├── .eslintrc.js              # eslint config\n├── index.html                # main html file\n└── package.json              # build scripts and dependencies\n```\n\n我们发现这里也有一个 .babelrc，内容跟之前自己创建的基本一致，可以忽略它。此外，它还提供了 .eslintrc.js，是为了配合 eslint 检查代码是否符合规范的。这里面的内容很简单，想要偷懒就直接拿过来，觉得定制的规则不太符合自己的习惯的可以另外配置。\n\n然后看到 build 路径下有 3 个 webpack 有关的配置文件，因为我们是要搭建开发环境，所以挑里面的 webpack.base.conf.js 和 webpack.dev.conf.js 就可以，建议把内容合并到一个 webpack.conf.js 文件里，放在项目的根目录下。\n\n之后，基本上就是把 src 目录移动到之前用 Express 创建的 /src/client/，我习惯将所有 js 的入口文件都改为 index.js 所以，这里也可以将 src/client/main.js 改名为 src/client/index.js。\n\n其他的文件先忽略不管。\n\n到这里，前端部分的代码也基本整理完毕了。\n\n### 3. 配置 Webpack\n\n我们计划让 Webpack 将前端文件打包成一个 build.js 文件，然后放在 /src/server/public/javascripts 中供 jade 模板使用。所以设置好 webpack 的路径部分（其他的保留原来的就好）：\n\n```javascript\n{\n  ...\n  entry: path.join(__dirname, 'src/client/index.js'),\n    output: {\n      path: path.join(__dirname, 'src/server/public/javascripts/'),\n      publicPath: '/javascripts/',\n      filename: 'build.js'\n    },\n  ...\n}\n```\n\n至于如何启动 Webpack，你可以选择单独用一个 shell 窗口运行它，也可以以 Express 中间件的形式提供代理。采用后一种方式，webpack 并不会把打包好的代码生成在磁盘上，而是保留在内存里。我们选择后一种方式，因为更方便。\n\n> 只应该在开发环境中以 Express 中间件的形式部署 Webpack\n\n所以需要修改 /src/server/index.js，关键是增加这几句\n\n```javascript\nimport webpack from 'webpack'\nimport webpackDevMiddleware from 'webpack-dev-middleware'\nimport webpackHotMiddleware from 'webpack-hot-middleware'\nimport config from '../../webpack.config'\n\nconst compiler = webpack(config)\n\napp.use(webpackDevMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  stats: { colors: true },\n}))\n\napp.use(webpackHotMiddleware(compiler))\n```\n\n这样每次启动 Express 后，Webpack 中间件会拦截 config.output.publicPath 地址的请求并返回正确的结果，同时，如果被 Webpack 监听的文件发生变动，会立即通知前端产生相应变化。\n\n### 4. 配置 Nodemon\n\n之前提到过，计划用 Nodemon 启动 server 并监听代码变动。而 Nodemon 默认会监听除了 .git 和 node_modules 路径外的所有 js 代码，因为我们已经有 Webpack 监听前端代码了，所以得做相关配置让 Nodemon 只监听某一块代码。\n\n在项目根路径下新增文件 nodemon.json，内容为\n\n```\n{\n  \"verbose\": true,\n  \"ignore\": [\"src/server/public/\"],\n  \"events\": {\n    \"restart\": \"osascript -e 'display notification \\\"App restarted due to:\\n'$FILENAME'\\\" with title \\\"nodemon\\\"'\"\n  },\n  \"watch\": [\"src/server/\"],\n  \"env\": {\n    \"NODE_ENV\": \"development\"\n  },\n  \"ext\": \"js jade\"\n}\n```\n\n其中，将 verbose 设置为 true 将打印更丰富的日志信息，对开发很有帮助。\n\n我们选择让 Nodemon 监听 src/server/ 目录，并忽略 src/server/public 目录，因为那里是前端 webpack 生成打包文件的地方。注意我们是以 Express 中间件的形式使用 Webpack，并不会在磁盘上真的产生文件，所以这个 ignore 规则其实可以省略。\n\n别忘了在文件扩展名中增加 jade 类型，因为 Express 使用的是 jade 模板。\n\n### 5. 配置 package.json\n\n首先在 script 中增加一个命令，用来启动整个应用\n\n```javascript\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"nodemon index.js\"\n  },\n  ...\n}\n```\n\n这样，只需要运行 `npm run dev` 这一个命令就可以启动 server 同时进行开发了。\n","source":"_posts/setup-express-vue-boilerplate.md","raw":"title: 从零开始搭建 Express + Vue 开发环境\ndate: 2016-02-28 14:02:16\ntags: express, vue, webpack, node\n---\n\n完整的代码已经上传 Github，[点击访问](https://github.com/southerncross/vue-express-dev-boilerplate)\n\n## 准备工作\n\n### 1. 为前端选择合适的预处理工具和资源管理工具\n\n预处理工具又分为 js 预处理工具和 css 预处理工具。Javascript 一直以来最为人诟病的一点就是缺乏原生的模块机制，所有 js 代码文件在被 html 页面引入后将共用同一个命名空间。所以才出现了各种“标准”尝试解决这个问题，但他们都不是原生的，需要额外的工具对代码进行特殊处理。虽然 ES6 终于引入了模块机制，但以现在的浏览器支持程度，还不足以“毫无顾虑地随拿随用”。所以 js 预处理工具最主要的工作就是帮助解决 js 的模块问题。而 css 预处理工具则很好理解，就是把 sass，less 或者 stylus 代码翻译、合并成 css 代码。\n\n资源管理工具则是帮我们管理前端所需的各种资源文件（比如 css、js、图片、字体等等），便于我们引用。目前常用的解决方法是将他们直接编码进 js 代码中，然后像引用 js 模块一样引用它们。这可比手写各种 url 方便多了。\n\n正如标题所说，我们将采用 Webpack，因为它具备上面所说的所有功能。此外还支持代码热替换，使修改代码后不用刷新页面也能在浏览器中立即看到效果。\n\n![Webpack schedule](http://webpack.github.io/assets/what-is-webpack.png)\n\n### 2. 为后端选择合适的预处理工具\n\n后端面对的都是 js 代码，不需要前端那样的资源管理工具，另外， Node 强迫你使用至少一种模块管理方案（CommonJS 或 ES6 的 import），也不用考虑代码的依赖问题。\n\n所以后端要简单许多，唯一需要考虑的基本上就剩下如何将 ES6 转译成 ES5 了（如果你打算使用 ES6 的话）。目前常用的做法是使用 Babel，你可以用 Babel 命令行工具独立执行编译过程，也可以配置 Babel register 实现代码运行时动态翻译，这对于开发场景而言无疑是最方便的。所以我们选择后一种方式。\n\n![Babel logo](https://babeljs.io/images/logo.svg)\n\n### 3. 为整个项目选择合适的流程控制工具\n\n流程控制工具是为了帮助我们管理诸如代码检查、编译、压缩、移动、部署这些任务的，原本我们是通过手敲命令（或者高级一点写个脚本）的方式做，有了流程控制工具以后，只需要提供配置文件和少量代码就可以完成。\n\n目前最流行的解决方案是 gulp。不过，由于我们这里要搭建的是开发环境，没有移动代码、压缩、部署等需求，所以不需要功能强大的 gulp。我们只要用 nodemon 这个工具监听代码变动然后适时重启 server就够了。\n\n![Nodemon logo](https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667)\n\n## 正式开始搭建\n\n### 1. 利用 Express 脚手架快速搭建应用\n\n使用 Express 提供的脚手架工具（[Express application generator](http://expressjs.com/en/starter/generator.html)）可以在 1s 之内搭建出最基本的应用。\n\n如果你以前还没试过，首先执行下面的命令安装\n\n`npm install express-generator -g`\n\n然后执行以下命令生成代码，命令执行过程中需要输入一些参数。\n\n`express <myapp>`\n\n完成后的文件结构是这样的\n\n```\n.\n├── app.js\n├── bin\n│   └── www\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n```\n\n但是这个文件结构只是后端代码，要想跟前端代码相结合，需要做一些改动。我们计划最终的文件结构应该是这样的\n\n```\n.\n├── src\n│   ├── client\n│   └── server\n└── ...\n```\n\n所以需要将上面自动生成的 Express 代码放到 /src/server/ 路径下。\n\n接下来我们要删除一些用不着的东西以及增加一些缺失的东西。\n\n首先，由于我们打算在前端使用 Vue 框架，并由 Vue-Router 管理大部分路由，后端 Express 仅保留少量的 RESTful API 路由，所以后端不需要复杂的路由设置，那么 routes 文件夹下的内容可以简化成一个 routers.js 文件。\n\n然后，我们需要配置好 Babel register，所以需要在项目跟路径下新增两个文件 `.babelrc` 和 `index.js`，内容分别为：\n\n/.babelrc\n```json\n{\n  \"presets\": [\"es2015\"],\n}\n```\n.babelrc 是 Babel 6.0 必须的文件\n\n/.index.js\n```\nrequire('babel-register')\nrequire('./src/server')\n```\n上面两句完成 Bebel 注册，它会爬取所有 `require` 或 `import` 方式依赖的模块并把它们翻译成 ES5。\n\n自动生成的代码里有个 www 文件，他是 Express 应用的入口文件，我们把它放在 server 路径下并改名为 index.js 以便让上面配置的 Babel register 能正确找到它。\n\n> 为什么要改名为 index.js ？这是因为 `require('./src/server')` 在默认情况下会去找 ./src/server/index.js，如果你想用别的名字，那就记得将 Babel register 的配置文件里改为 `require(./src/<your entry file>`。\n\n好了，现在后端的事情先暂时告一段落，接下来看看前端。\n\n### 2. 利用 Vue 脚手架快速搭建应用\n\n同样地，推荐使用 Vue 自带的 [template 工具](https://github.com/vuejs-templates/webpack)，在 1s 内生成基本代码。\n\n虽然利用这个工具生成的代码的后端就是基于 Express 的，但是后端部分的代码结构太简单，不适合做后续开发。所以建议这里先将 Vue 生成的代码放在另外一个地方，然后按需移动到前面用 Express 生成的代码文件夹里。\n\n首先安装 template 工具\n\n`npm install -g vue-cli`\n\n然后执行命令生成代码。命令执行过程中需要输入一些参数\n\n`vue init webpack <my-project>`\n\n生成的代码结构是这样的\n\n```\n.\n├── build\n│   ├── dev-server.js         # development server script\n│   ├── karma.conf.js         # unit testing config\n│   ├── webpack.base.conf.js  # shared base webpack config\n│   ├── webpack.dev.conf.js   # development webpack config\n│   ├── webpack.prod.conf.js  # production webpack config\n│   └── ...\n├── src\n│   ├── main.js               # app entry file\n│   ├── App.vue               # main app component\n│   ├── components            # ui components\n│   │   └── ...\n│   └── assets                # module assets (processed by webpack)\n│       └── ...\n├── static                    # pure static assets (directly copied)\n├── dist                      # built files ready for deploy\n├── test\n│   └── unit                  # unit tests\n│       ├── index.js          # unit test entry file\n│       └── ...\n├── .babelrc                  # babel config\n├── .eslintrc.js              # eslint config\n├── index.html                # main html file\n└── package.json              # build scripts and dependencies\n```\n\n我们发现这里也有一个 .babelrc，内容跟之前自己创建的基本一致，可以忽略它。此外，它还提供了 .eslintrc.js，是为了配合 eslint 检查代码是否符合规范的。这里面的内容很简单，想要偷懒就直接拿过来，觉得定制的规则不太符合自己的习惯的可以另外配置。\n\n然后看到 build 路径下有 3 个 webpack 有关的配置文件，因为我们是要搭建开发环境，所以挑里面的 webpack.base.conf.js 和 webpack.dev.conf.js 就可以，建议把内容合并到一个 webpack.conf.js 文件里，放在项目的根目录下。\n\n之后，基本上就是把 src 目录移动到之前用 Express 创建的 /src/client/，我习惯将所有 js 的入口文件都改为 index.js 所以，这里也可以将 src/client/main.js 改名为 src/client/index.js。\n\n其他的文件先忽略不管。\n\n到这里，前端部分的代码也基本整理完毕了。\n\n### 3. 配置 Webpack\n\n我们计划让 Webpack 将前端文件打包成一个 build.js 文件，然后放在 /src/server/public/javascripts 中供 jade 模板使用。所以设置好 webpack 的路径部分（其他的保留原来的就好）：\n\n```javascript\n{\n  ...\n  entry: path.join(__dirname, 'src/client/index.js'),\n    output: {\n      path: path.join(__dirname, 'src/server/public/javascripts/'),\n      publicPath: '/javascripts/',\n      filename: 'build.js'\n    },\n  ...\n}\n```\n\n至于如何启动 Webpack，你可以选择单独用一个 shell 窗口运行它，也可以以 Express 中间件的形式提供代理。采用后一种方式，webpack 并不会把打包好的代码生成在磁盘上，而是保留在内存里。我们选择后一种方式，因为更方便。\n\n> 只应该在开发环境中以 Express 中间件的形式部署 Webpack\n\n所以需要修改 /src/server/index.js，关键是增加这几句\n\n```javascript\nimport webpack from 'webpack'\nimport webpackDevMiddleware from 'webpack-dev-middleware'\nimport webpackHotMiddleware from 'webpack-hot-middleware'\nimport config from '../../webpack.config'\n\nconst compiler = webpack(config)\n\napp.use(webpackDevMiddleware(compiler, {\n  publicPath: config.output.publicPath,\n  stats: { colors: true },\n}))\n\napp.use(webpackHotMiddleware(compiler))\n```\n\n这样每次启动 Express 后，Webpack 中间件会拦截 config.output.publicPath 地址的请求并返回正确的结果，同时，如果被 Webpack 监听的文件发生变动，会立即通知前端产生相应变化。\n\n### 4. 配置 Nodemon\n\n之前提到过，计划用 Nodemon 启动 server 并监听代码变动。而 Nodemon 默认会监听除了 .git 和 node_modules 路径外的所有 js 代码，因为我们已经有 Webpack 监听前端代码了，所以得做相关配置让 Nodemon 只监听某一块代码。\n\n在项目根路径下新增文件 nodemon.json，内容为\n\n```\n{\n  \"verbose\": true,\n  \"ignore\": [\"src/server/public/\"],\n  \"events\": {\n    \"restart\": \"osascript -e 'display notification \\\"App restarted due to:\\n'$FILENAME'\\\" with title \\\"nodemon\\\"'\"\n  },\n  \"watch\": [\"src/server/\"],\n  \"env\": {\n    \"NODE_ENV\": \"development\"\n  },\n  \"ext\": \"js jade\"\n}\n```\n\n其中，将 verbose 设置为 true 将打印更丰富的日志信息，对开发很有帮助。\n\n我们选择让 Nodemon 监听 src/server/ 目录，并忽略 src/server/public 目录，因为那里是前端 webpack 生成打包文件的地方。注意我们是以 Express 中间件的形式使用 Webpack，并不会在磁盘上真的产生文件，所以这个 ignore 规则其实可以省略。\n\n别忘了在文件扩展名中增加 jade 类型，因为 Express 使用的是 jade 模板。\n\n### 5. 配置 package.json\n\n首先在 script 中增加一个命令，用来启动整个应用\n\n```javascript\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"nodemon index.js\"\n  },\n  ...\n}\n```\n\n这样，只需要运行 `npm run dev` 这一个命令就可以启动 server 同时进行开发了。\n","slug":"setup-express-vue-boilerplate","published":1,"updated":"2016-02-28T09:00:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvhj9vkm000eu9yyzd7y3rrq","content":"<p>完整的代码已经上传 Github，<a href=\"https://github.com/southerncross/vue-express-dev-boilerplate\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"1-为前端选择合适的预处理工具和资源管理工具\"><a href=\"#1-为前端选择合适的预处理工具和资源管理工具\" class=\"headerlink\" title=\"1. 为前端选择合适的预处理工具和资源管理工具\"></a>1. 为前端选择合适的预处理工具和资源管理工具</h3><p>预处理工具又分为 js 预处理工具和 css 预处理工具。Javascript 一直以来最为人诟病的一点就是缺乏原生的模块机制，所有 js 代码文件在被 html 页面引入后将共用同一个命名空间。所以才出现了各种“标准”尝试解决这个问题，但他们都不是原生的，需要额外的工具对代码进行特殊处理。虽然 ES6 终于引入了模块机制，但以现在的浏览器支持程度，还不足以“毫无顾虑地随拿随用”。所以 js 预处理工具最主要的工作就是帮助解决 js 的模块问题。而 css 预处理工具则很好理解，就是把 sass，less 或者 stylus 代码翻译、合并成 css 代码。</p>\n<p>资源管理工具则是帮我们管理前端所需的各种资源文件（比如 css、js、图片、字体等等），便于我们引用。目前常用的解决方法是将他们直接编码进 js 代码中，然后像引用 js 模块一样引用它们。这可比手写各种 url 方便多了。</p>\n<p>正如标题所说，我们将采用 Webpack，因为它具备上面所说的所有功能。此外还支持代码热替换，使修改代码后不用刷新页面也能在浏览器中立即看到效果。</p>\n<p><img src=\"http://webpack.github.io/assets/what-is-webpack.png\" alt=\"Webpack schedule\"></p>\n<h3 id=\"2-为后端选择合适的预处理工具\"><a href=\"#2-为后端选择合适的预处理工具\" class=\"headerlink\" title=\"2. 为后端选择合适的预处理工具\"></a>2. 为后端选择合适的预处理工具</h3><p>后端面对的都是 js 代码，不需要前端那样的资源管理工具，另外， Node 强迫你使用至少一种模块管理方案（CommonJS 或 ES6 的 import），也不用考虑代码的依赖问题。</p>\n<p>所以后端要简单许多，唯一需要考虑的基本上就剩下如何将 ES6 转译成 ES5 了（如果你打算使用 ES6 的话）。目前常用的做法是使用 Babel，你可以用 Babel 命令行工具独立执行编译过程，也可以配置 Babel register 实现代码运行时动态翻译，这对于开发场景而言无疑是最方便的。所以我们选择后一种方式。</p>\n<p><img src=\"https://babeljs.io/images/logo.svg\" alt=\"Babel logo\"></p>\n<h3 id=\"3-为整个项目选择合适的流程控制工具\"><a href=\"#3-为整个项目选择合适的流程控制工具\" class=\"headerlink\" title=\"3. 为整个项目选择合适的流程控制工具\"></a>3. 为整个项目选择合适的流程控制工具</h3><p>流程控制工具是为了帮助我们管理诸如代码检查、编译、压缩、移动、部署这些任务的，原本我们是通过手敲命令（或者高级一点写个脚本）的方式做，有了流程控制工具以后，只需要提供配置文件和少量代码就可以完成。</p>\n<p>目前最流行的解决方案是 gulp。不过，由于我们这里要搭建的是开发环境，没有移动代码、压缩、部署等需求，所以不需要功能强大的 gulp。我们只要用 nodemon 这个工具监听代码变动然后适时重启 server就够了。</p>\n<p><img src=\"https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667\" alt=\"Nodemon logo\"></p>\n<h2 id=\"正式开始搭建\"><a href=\"#正式开始搭建\" class=\"headerlink\" title=\"正式开始搭建\"></a>正式开始搭建</h2><h3 id=\"1-利用-Express-脚手架快速搭建应用\"><a href=\"#1-利用-Express-脚手架快速搭建应用\" class=\"headerlink\" title=\"1. 利用 Express 脚手架快速搭建应用\"></a>1. 利用 Express 脚手架快速搭建应用</h3><p>使用 Express 提供的脚手架工具（<a href=\"http://expressjs.com/en/starter/generator.html\" target=\"_blank\" rel=\"noopener\">Express application generator</a>）可以在 1s 之内搭建出最基本的应用。</p>\n<p>如果你以前还没试过，首先执行下面的命令安装</p>\n<p><code>npm install express-generator -g</code></p>\n<p>然后执行以下命令生成代码，命令执行过程中需要输入一些参数。</p>\n<p><code>express &lt;myapp&gt;</code></p>\n<p>完成后的文件结构是这样的</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── app.js</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── public</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">│       └── style.css</span><br><span class=\"line\">├── routes</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    ├── error.jade</span><br><span class=\"line\">    ├── index.jade</span><br><span class=\"line\">    └── layout.jade</span><br></pre></td></tr></table></figure>\n<p>但是这个文件结构只是后端代码，要想跟前端代码相结合，需要做一些改动。我们计划最终的文件结构应该是这样的</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── client</span><br><span class=\"line\">│   └── server</span><br><span class=\"line\">└── <span class=\"built_in\">..</span>.</span><br></pre></td></tr></table></figure>\n<p>所以需要将上面自动生成的 Express 代码放到 /src/server/ 路径下。</p>\n<p>接下来我们要删除一些用不着的东西以及增加一些缺失的东西。</p>\n<p>首先，由于我们打算在前端使用 Vue 框架，并由 Vue-Router 管理大部分路由，后端 Express 仅保留少量的 RESTful API 路由，所以后端不需要复杂的路由设置，那么 routes 文件夹下的内容可以简化成一个 routers.js 文件。</p>\n<p>然后，我们需要配置好 Babel register，所以需要在项目跟路径下新增两个文件 <code>.babelrc</code> 和 <code>index.js</code>，内容分别为：</p>\n<p>/.babelrc<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>.babelrc 是 Babel 6.0 必须的文件</p>\n<p>/.index.js<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">require</span><span class=\"params\">(<span class=\"string\">'babel-register'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">require</span><span class=\"params\">(<span class=\"string\">'./src/server'</span>)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>上面两句完成 Bebel 注册，它会爬取所有 <code>require</code> 或 <code>import</code> 方式依赖的模块并把它们翻译成 ES5。</p>\n<p>自动生成的代码里有个 www 文件，他是 Express 应用的入口文件，我们把它放在 server 路径下并改名为 index.js 以便让上面配置的 Babel register 能正确找到它。</p>\n<blockquote>\n<p>为什么要改名为 index.js ？这是因为 <code>require(&#39;./src/server&#39;)</code> 在默认情况下会去找 ./src/server/index.js，如果你想用别的名字，那就记得将 Babel register 的配置文件里改为 <code>require(./src/&lt;your entry file&gt;</code>。</p>\n</blockquote>\n<p>好了，现在后端的事情先暂时告一段落，接下来看看前端。</p>\n<h3 id=\"2-利用-Vue-脚手架快速搭建应用\"><a href=\"#2-利用-Vue-脚手架快速搭建应用\" class=\"headerlink\" title=\"2. 利用 Vue 脚手架快速搭建应用\"></a>2. 利用 Vue 脚手架快速搭建应用</h3><p>同样地，推荐使用 Vue 自带的 <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">template 工具</a>，在 1s 内生成基本代码。</p>\n<p>虽然利用这个工具生成的代码的后端就是基于 Express 的，但是后端部分的代码结构太简单，不适合做后续开发。所以建议这里先将 Vue 生成的代码放在另外一个地方，然后按需移动到前面用 Express 生成的代码文件夹里。</p>\n<p>首先安装 template 工具</p>\n<p><code>npm install -g vue-cli</code></p>\n<p>然后执行命令生成代码。命令执行过程中需要输入一些参数</p>\n<p><code>vue init webpack &lt;my-project&gt;</code></p>\n<p>生成的代码结构是这样的</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build</span><br><span class=\"line\">│   ├── dev-server.js         # development<span class=\"built_in\"> server </span>script</span><br><span class=\"line\">│   ├── karma.conf.js         # unit testing config</span><br><span class=\"line\">│   ├── webpack.base.conf.js  # shared base webpack config</span><br><span class=\"line\">│   ├── webpack.dev.conf.js   # development webpack config</span><br><span class=\"line\">│   ├── webpack.prod.conf.js  # production webpack config</span><br><span class=\"line\">│   └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── main.js               # app entry file</span><br><span class=\"line\">│   ├── App.vue               # main app component</span><br><span class=\"line\">│   ├── components            # ui components</span><br><span class=\"line\">│   │   └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">│   └── assets                # module assets (processed by webpack)</span><br><span class=\"line\">│       └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">├── static                    # pure static assets (directly copied)</span><br><span class=\"line\">├── dist                      # built files ready <span class=\"keyword\">for</span> deploy</span><br><span class=\"line\">├── test</span><br><span class=\"line\">│   └── unit                  # unit tests</span><br><span class=\"line\">│       ├── index.js          # unit test entry file</span><br><span class=\"line\">│       └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">├── .babelrc                  # babel config</span><br><span class=\"line\">├── .eslintrc.js              # eslint config</span><br><span class=\"line\">├── index.html                # main html file</span><br><span class=\"line\">└── package.json              # build scripts <span class=\"keyword\">and</span> dependencies</span><br></pre></td></tr></table></figure>\n<p>我们发现这里也有一个 .babelrc，内容跟之前自己创建的基本一致，可以忽略它。此外，它还提供了 .eslintrc.js，是为了配合 eslint 检查代码是否符合规范的。这里面的内容很简单，想要偷懒就直接拿过来，觉得定制的规则不太符合自己的习惯的可以另外配置。</p>\n<p>然后看到 build 路径下有 3 个 webpack 有关的配置文件，因为我们是要搭建开发环境，所以挑里面的 webpack.base.conf.js 和 webpack.dev.conf.js 就可以，建议把内容合并到一个 webpack.conf.js 文件里，放在项目的根目录下。</p>\n<p>之后，基本上就是把 src 目录移动到之前用 Express 创建的 /src/client/，我习惯将所有 js 的入口文件都改为 index.js 所以，这里也可以将 src/client/main.js 改名为 src/client/index.js。</p>\n<p>其他的文件先忽略不管。</p>\n<p>到这里，前端部分的代码也基本整理完毕了。</p>\n<h3 id=\"3-配置-Webpack\"><a href=\"#3-配置-Webpack\" class=\"headerlink\" title=\"3. 配置 Webpack\"></a>3. 配置 Webpack</h3><p>我们计划让 Webpack 将前端文件打包成一个 build.js 文件，然后放在 /src/server/public/javascripts 中供 jade 模板使用。所以设置好 webpack 的路径部分（其他的保留原来的就好）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  entry: path.join(__dirname, <span class=\"string\">'src/client/index.js'</span>),</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      path: path.join(__dirname, <span class=\"string\">'src/server/public/javascripts/'</span>),</span><br><span class=\"line\">      publicPath: <span class=\"string\">'/javascripts/'</span>,</span><br><span class=\"line\">      filename: <span class=\"string\">'build.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至于如何启动 Webpack，你可以选择单独用一个 shell 窗口运行它，也可以以 Express 中间件的形式提供代理。采用后一种方式，webpack 并不会把打包好的代码生成在磁盘上，而是保留在内存里。我们选择后一种方式，因为更方便。</p>\n<blockquote>\n<p>只应该在开发环境中以 Express 中间件的形式部署 Webpack</p>\n</blockquote>\n<p>所以需要修改 /src/server/index.js，关键是增加这几句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> webpack <span class=\"keyword\">from</span> <span class=\"string\">'webpack'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> webpackDevMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'webpack-dev-middleware'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> webpackHotMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'webpack-hot-middleware'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> config <span class=\"keyword\">from</span> <span class=\"string\">'../../webpack.config'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compiler = webpack(config)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class=\"line\">  publicPath: config.output.publicPath,</span><br><span class=\"line\">  stats: &#123; <span class=\"attr\">colors</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(webpackHotMiddleware(compiler))</span><br></pre></td></tr></table></figure>\n<p>这样每次启动 Express 后，Webpack 中间件会拦截 config.output.publicPath 地址的请求并返回正确的结果，同时，如果被 Webpack 监听的文件发生变动，会立即通知前端产生相应变化。</p>\n<h3 id=\"4-配置-Nodemon\"><a href=\"#4-配置-Nodemon\" class=\"headerlink\" title=\"4. 配置 Nodemon\"></a>4. 配置 Nodemon</h3><p>之前提到过，计划用 Nodemon 启动 server 并监听代码变动。而 Nodemon 默认会监听除了 .git 和 node_modules 路径外的所有 js 代码，因为我们已经有 Webpack 监听前端代码了，所以得做相关配置让 Nodemon 只监听某一块代码。</p>\n<p>在项目根路径下新增文件 nodemon.json，内容为</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"verbose\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"ignore\"</span>: [<span class=\"string\">\"src/server/public/\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"events\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"restart\"</span>: <span class=\"string\">\"osascript -e 'display notification \\\"App restarted due to:\\n'$FILENAME'\\\" with title \\\"nodemon\\\"'\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"watch\"</span>: [<span class=\"string\">\"src/server/\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"env\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"NODE_ENV\"</span>: <span class=\"string\">\"development\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"ext\"</span>: <span class=\"string\">\"js jade\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，将 verbose 设置为 true 将打印更丰富的日志信息，对开发很有帮助。</p>\n<p>我们选择让 Nodemon 监听 src/server/ 目录，并忽略 src/server/public 目录，因为那里是前端 webpack 生成打包文件的地方。注意我们是以 Express 中间件的形式使用 Webpack，并不会在磁盘上真的产生文件，所以这个 ignore 规则其实可以省略。</p>\n<p>别忘了在文件扩展名中增加 jade 类型，因为 Express 使用的是 jade 模板。</p>\n<h3 id=\"5-配置-package-json\"><a href=\"#5-配置-package-json\" class=\"headerlink\" title=\"5. 配置 package.json\"></a>5. 配置 package.json</h3><p>首先在 script 中增加一个命令，用来启动整个应用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"nodemon index.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，只需要运行 <code>npm run dev</code> 这一个命令就可以启动 server 同时进行开发了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>完整的代码已经上传 Github，<a href=\"https://github.com/southerncross/vue-express-dev-boilerplate\" target=\"_blank\" rel=\"noopener\">点击访问</a></p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"1-为前端选择合适的预处理工具和资源管理工具\"><a href=\"#1-为前端选择合适的预处理工具和资源管理工具\" class=\"headerlink\" title=\"1. 为前端选择合适的预处理工具和资源管理工具\"></a>1. 为前端选择合适的预处理工具和资源管理工具</h3><p>预处理工具又分为 js 预处理工具和 css 预处理工具。Javascript 一直以来最为人诟病的一点就是缺乏原生的模块机制，所有 js 代码文件在被 html 页面引入后将共用同一个命名空间。所以才出现了各种“标准”尝试解决这个问题，但他们都不是原生的，需要额外的工具对代码进行特殊处理。虽然 ES6 终于引入了模块机制，但以现在的浏览器支持程度，还不足以“毫无顾虑地随拿随用”。所以 js 预处理工具最主要的工作就是帮助解决 js 的模块问题。而 css 预处理工具则很好理解，就是把 sass，less 或者 stylus 代码翻译、合并成 css 代码。</p>\n<p>资源管理工具则是帮我们管理前端所需的各种资源文件（比如 css、js、图片、字体等等），便于我们引用。目前常用的解决方法是将他们直接编码进 js 代码中，然后像引用 js 模块一样引用它们。这可比手写各种 url 方便多了。</p>\n<p>正如标题所说，我们将采用 Webpack，因为它具备上面所说的所有功能。此外还支持代码热替换，使修改代码后不用刷新页面也能在浏览器中立即看到效果。</p>\n<p><img src=\"http://webpack.github.io/assets/what-is-webpack.png\" alt=\"Webpack schedule\"></p>\n<h3 id=\"2-为后端选择合适的预处理工具\"><a href=\"#2-为后端选择合适的预处理工具\" class=\"headerlink\" title=\"2. 为后端选择合适的预处理工具\"></a>2. 为后端选择合适的预处理工具</h3><p>后端面对的都是 js 代码，不需要前端那样的资源管理工具，另外， Node 强迫你使用至少一种模块管理方案（CommonJS 或 ES6 的 import），也不用考虑代码的依赖问题。</p>\n<p>所以后端要简单许多，唯一需要考虑的基本上就剩下如何将 ES6 转译成 ES5 了（如果你打算使用 ES6 的话）。目前常用的做法是使用 Babel，你可以用 Babel 命令行工具独立执行编译过程，也可以配置 Babel register 实现代码运行时动态翻译，这对于开发场景而言无疑是最方便的。所以我们选择后一种方式。</p>\n<p><img src=\"https://babeljs.io/images/logo.svg\" alt=\"Babel logo\"></p>\n<h3 id=\"3-为整个项目选择合适的流程控制工具\"><a href=\"#3-为整个项目选择合适的流程控制工具\" class=\"headerlink\" title=\"3. 为整个项目选择合适的流程控制工具\"></a>3. 为整个项目选择合适的流程控制工具</h3><p>流程控制工具是为了帮助我们管理诸如代码检查、编译、压缩、移动、部署这些任务的，原本我们是通过手敲命令（或者高级一点写个脚本）的方式做，有了流程控制工具以后，只需要提供配置文件和少量代码就可以完成。</p>\n<p>目前最流行的解决方案是 gulp。不过，由于我们这里要搭建的是开发环境，没有移动代码、压缩、部署等需求，所以不需要功能强大的 gulp。我们只要用 nodemon 这个工具监听代码变动然后适时重启 server就够了。</p>\n<p><img src=\"https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667\" alt=\"Nodemon logo\"></p>\n<h2 id=\"正式开始搭建\"><a href=\"#正式开始搭建\" class=\"headerlink\" title=\"正式开始搭建\"></a>正式开始搭建</h2><h3 id=\"1-利用-Express-脚手架快速搭建应用\"><a href=\"#1-利用-Express-脚手架快速搭建应用\" class=\"headerlink\" title=\"1. 利用 Express 脚手架快速搭建应用\"></a>1. 利用 Express 脚手架快速搭建应用</h3><p>使用 Express 提供的脚手架工具（<a href=\"http://expressjs.com/en/starter/generator.html\" target=\"_blank\" rel=\"noopener\">Express application generator</a>）可以在 1s 之内搭建出最基本的应用。</p>\n<p>如果你以前还没试过，首先执行下面的命令安装</p>\n<p><code>npm install express-generator -g</code></p>\n<p>然后执行以下命令生成代码，命令执行过程中需要输入一些参数。</p>\n<p><code>express &lt;myapp&gt;</code></p>\n<p>完成后的文件结构是这样的</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── app.js</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── public</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">│       └── style.css</span><br><span class=\"line\">├── routes</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    ├── error.jade</span><br><span class=\"line\">    ├── index.jade</span><br><span class=\"line\">    └── layout.jade</span><br></pre></td></tr></table></figure>\n<p>但是这个文件结构只是后端代码，要想跟前端代码相结合，需要做一些改动。我们计划最终的文件结构应该是这样的</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── client</span><br><span class=\"line\">│   └── server</span><br><span class=\"line\">└── <span class=\"built_in\">..</span>.</span><br></pre></td></tr></table></figure>\n<p>所以需要将上面自动生成的 Express 代码放到 /src/server/ 路径下。</p>\n<p>接下来我们要删除一些用不着的东西以及增加一些缺失的东西。</p>\n<p>首先，由于我们打算在前端使用 Vue 框架，并由 Vue-Router 管理大部分路由，后端 Express 仅保留少量的 RESTful API 路由，所以后端不需要复杂的路由设置，那么 routes 文件夹下的内容可以简化成一个 routers.js 文件。</p>\n<p>然后，我们需要配置好 Babel register，所以需要在项目跟路径下新增两个文件 <code>.babelrc</code> 和 <code>index.js</code>，内容分别为：</p>\n<p>/.babelrc<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"presets\"</span>: [<span class=\"string\">\"es2015\"</span>],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>.babelrc 是 Babel 6.0 必须的文件</p>\n<p>/.index.js<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">require</span><span class=\"params\">(<span class=\"string\">'babel-register'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">require</span><span class=\"params\">(<span class=\"string\">'./src/server'</span>)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>上面两句完成 Bebel 注册，它会爬取所有 <code>require</code> 或 <code>import</code> 方式依赖的模块并把它们翻译成 ES5。</p>\n<p>自动生成的代码里有个 www 文件，他是 Express 应用的入口文件，我们把它放在 server 路径下并改名为 index.js 以便让上面配置的 Babel register 能正确找到它。</p>\n<blockquote>\n<p>为什么要改名为 index.js ？这是因为 <code>require(&#39;./src/server&#39;)</code> 在默认情况下会去找 ./src/server/index.js，如果你想用别的名字，那就记得将 Babel register 的配置文件里改为 <code>require(./src/&lt;your entry file&gt;</code>。</p>\n</blockquote>\n<p>好了，现在后端的事情先暂时告一段落，接下来看看前端。</p>\n<h3 id=\"2-利用-Vue-脚手架快速搭建应用\"><a href=\"#2-利用-Vue-脚手架快速搭建应用\" class=\"headerlink\" title=\"2. 利用 Vue 脚手架快速搭建应用\"></a>2. 利用 Vue 脚手架快速搭建应用</h3><p>同样地，推荐使用 Vue 自带的 <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">template 工具</a>，在 1s 内生成基本代码。</p>\n<p>虽然利用这个工具生成的代码的后端就是基于 Express 的，但是后端部分的代码结构太简单，不适合做后续开发。所以建议这里先将 Vue 生成的代码放在另外一个地方，然后按需移动到前面用 Express 生成的代码文件夹里。</p>\n<p>首先安装 template 工具</p>\n<p><code>npm install -g vue-cli</code></p>\n<p>然后执行命令生成代码。命令执行过程中需要输入一些参数</p>\n<p><code>vue init webpack &lt;my-project&gt;</code></p>\n<p>生成的代码结构是这样的</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build</span><br><span class=\"line\">│   ├── dev-server.js         # development<span class=\"built_in\"> server </span>script</span><br><span class=\"line\">│   ├── karma.conf.js         # unit testing config</span><br><span class=\"line\">│   ├── webpack.base.conf.js  # shared base webpack config</span><br><span class=\"line\">│   ├── webpack.dev.conf.js   # development webpack config</span><br><span class=\"line\">│   ├── webpack.prod.conf.js  # production webpack config</span><br><span class=\"line\">│   └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── main.js               # app entry file</span><br><span class=\"line\">│   ├── App.vue               # main app component</span><br><span class=\"line\">│   ├── components            # ui components</span><br><span class=\"line\">│   │   └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">│   └── assets                # module assets (processed by webpack)</span><br><span class=\"line\">│       └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">├── static                    # pure static assets (directly copied)</span><br><span class=\"line\">├── dist                      # built files ready <span class=\"keyword\">for</span> deploy</span><br><span class=\"line\">├── test</span><br><span class=\"line\">│   └── unit                  # unit tests</span><br><span class=\"line\">│       ├── index.js          # unit test entry file</span><br><span class=\"line\">│       └── <span class=\"built_in\">..</span>.</span><br><span class=\"line\">├── .babelrc                  # babel config</span><br><span class=\"line\">├── .eslintrc.js              # eslint config</span><br><span class=\"line\">├── index.html                # main html file</span><br><span class=\"line\">└── package.json              # build scripts <span class=\"keyword\">and</span> dependencies</span><br></pre></td></tr></table></figure>\n<p>我们发现这里也有一个 .babelrc，内容跟之前自己创建的基本一致，可以忽略它。此外，它还提供了 .eslintrc.js，是为了配合 eslint 检查代码是否符合规范的。这里面的内容很简单，想要偷懒就直接拿过来，觉得定制的规则不太符合自己的习惯的可以另外配置。</p>\n<p>然后看到 build 路径下有 3 个 webpack 有关的配置文件，因为我们是要搭建开发环境，所以挑里面的 webpack.base.conf.js 和 webpack.dev.conf.js 就可以，建议把内容合并到一个 webpack.conf.js 文件里，放在项目的根目录下。</p>\n<p>之后，基本上就是把 src 目录移动到之前用 Express 创建的 /src/client/，我习惯将所有 js 的入口文件都改为 index.js 所以，这里也可以将 src/client/main.js 改名为 src/client/index.js。</p>\n<p>其他的文件先忽略不管。</p>\n<p>到这里，前端部分的代码也基本整理完毕了。</p>\n<h3 id=\"3-配置-Webpack\"><a href=\"#3-配置-Webpack\" class=\"headerlink\" title=\"3. 配置 Webpack\"></a>3. 配置 Webpack</h3><p>我们计划让 Webpack 将前端文件打包成一个 build.js 文件，然后放在 /src/server/public/javascripts 中供 jade 模板使用。所以设置好 webpack 的路径部分（其他的保留原来的就好）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  entry: path.join(__dirname, <span class=\"string\">'src/client/index.js'</span>),</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      path: path.join(__dirname, <span class=\"string\">'src/server/public/javascripts/'</span>),</span><br><span class=\"line\">      publicPath: <span class=\"string\">'/javascripts/'</span>,</span><br><span class=\"line\">      filename: <span class=\"string\">'build.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至于如何启动 Webpack，你可以选择单独用一个 shell 窗口运行它，也可以以 Express 中间件的形式提供代理。采用后一种方式，webpack 并不会把打包好的代码生成在磁盘上，而是保留在内存里。我们选择后一种方式，因为更方便。</p>\n<blockquote>\n<p>只应该在开发环境中以 Express 中间件的形式部署 Webpack</p>\n</blockquote>\n<p>所以需要修改 /src/server/index.js，关键是增加这几句</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> webpack <span class=\"keyword\">from</span> <span class=\"string\">'webpack'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> webpackDevMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'webpack-dev-middleware'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> webpackHotMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'webpack-hot-middleware'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> config <span class=\"keyword\">from</span> <span class=\"string\">'../../webpack.config'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compiler = webpack(config)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class=\"line\">  publicPath: config.output.publicPath,</span><br><span class=\"line\">  stats: &#123; <span class=\"attr\">colors</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(webpackHotMiddleware(compiler))</span><br></pre></td></tr></table></figure>\n<p>这样每次启动 Express 后，Webpack 中间件会拦截 config.output.publicPath 地址的请求并返回正确的结果，同时，如果被 Webpack 监听的文件发生变动，会立即通知前端产生相应变化。</p>\n<h3 id=\"4-配置-Nodemon\"><a href=\"#4-配置-Nodemon\" class=\"headerlink\" title=\"4. 配置 Nodemon\"></a>4. 配置 Nodemon</h3><p>之前提到过，计划用 Nodemon 启动 server 并监听代码变动。而 Nodemon 默认会监听除了 .git 和 node_modules 路径外的所有 js 代码，因为我们已经有 Webpack 监听前端代码了，所以得做相关配置让 Nodemon 只监听某一块代码。</p>\n<p>在项目根路径下新增文件 nodemon.json，内容为</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"verbose\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"ignore\"</span>: [<span class=\"string\">\"src/server/public/\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"events\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"restart\"</span>: <span class=\"string\">\"osascript -e 'display notification \\\"App restarted due to:\\n'$FILENAME'\\\" with title \\\"nodemon\\\"'\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"watch\"</span>: [<span class=\"string\">\"src/server/\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"env\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"NODE_ENV\"</span>: <span class=\"string\">\"development\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"ext\"</span>: <span class=\"string\">\"js jade\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，将 verbose 设置为 true 将打印更丰富的日志信息，对开发很有帮助。</p>\n<p>我们选择让 Nodemon 监听 src/server/ 目录，并忽略 src/server/public 目录，因为那里是前端 webpack 生成打包文件的地方。注意我们是以 Express 中间件的形式使用 Webpack，并不会在磁盘上真的产生文件，所以这个 ignore 规则其实可以省略。</p>\n<p>别忘了在文件扩展名中增加 jade 类型，因为 Express 使用的是 jade 模板。</p>\n<h3 id=\"5-配置-package-json\"><a href=\"#5-配置-package-json\" class=\"headerlink\" title=\"5. 配置 package.json\"></a>5. 配置 package.json</h3><p>首先在 script 中增加一个命令，用来启动整个应用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"nodemon index.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，只需要运行 <code>npm run dev</code> 这一个命令就可以启动 server 同时进行开发了。</p>\n"}],"PostAsset":[{"_id":"source/_posts/meteor-qiniu-client-upload-example/qiniu-upload-flow.png","post":"cjvhj9vkh0008u9yy1lxy8w1h","slug":"qiniu-upload-flow.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjvhj9vk10000u9yyjv76t2xm","tag_id":"cjvhj9vk60001u9yydqi7jpf9","_id":"cjvhj9vk70002u9yy5ejq96h8"},{"post_id":"cjvhj9vkc0003u9yyq15m0ejt","tag_id":"cjvhj9vkf0005u9yy5wfjzqah","_id":"cjvhj9vkk000au9yyn4m89epb"},{"post_id":"cjvhj9vkd0004u9yylsrtwsqm","tag_id":"cjvhj9vkj0009u9yy1td4e25y","_id":"cjvhj9vkn000fu9yyje6ox0se"},{"post_id":"cjvhj9vkm000eu9yyzd7y3rrq","tag_id":"cjvhj9vkf0005u9yy5wfjzqah","_id":"cjvhj9vko000hu9yyciszcrqz"},{"post_id":"cjvhj9vkf0006u9yywnym9ccs","tag_id":"cjvhj9vkm000du9yy3gnkzr8k","_id":"cjvhj9vko000iu9yyli7eth89"},{"post_id":"cjvhj9vkg0007u9yyj0eg0ff1","tag_id":"cjvhj9vko000gu9yykvls6296","_id":"cjvhj9vkp000ku9yy4vzmagaz"},{"post_id":"cjvhj9vkl000cu9yyh2w5j376","tag_id":"cjvhj9vko000ju9yyu9zybnm7","_id":"cjvhj9vkp000lu9yyjsz1lfbx"}],"Tag":[{"name":"network shell","_id":"cjvhj9vk60001u9yydqi7jpf9"},{"name":"express, vue, webpack, node","_id":"cjvhj9vkf0005u9yy5wfjzqah"},{"name":"React, Redux","_id":"cjvhj9vkj0009u9yy1td4e25y"},{"name":"front-end","_id":"cjvhj9vkm000du9yy3gnkzr8k"},{"name":"dingtalk isv","_id":"cjvhj9vko000gu9yykvls6296"},{"name":"javascript","_id":"cjvhj9vko000ju9yyu9zybnm7"}]}}