<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Shunyang Li's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://southerncross.github.io/"/>
  <updated>2016-02-28T09:00:52.000Z</updated>
  <id>http://southerncross.github.io/</id>
  
  <author>
    <name><![CDATA[Shunyang Li]]></name>
    <email><![CDATA[lishunyang@pku.edu.cn]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[从零开始搭建 Express + Vue 开发环境]]></title>
    <link href="http://southerncross.github.io/2016/02/28/setup-express-vue-boilerplate/"/>
    <id>http://southerncross.github.io/2016/02/28/setup-express-vue-boilerplate/</id>
    <published>2016-02-28T06:02:16.000Z</published>
    <updated>2016-02-28T09:00:52.000Z</updated>
    <content type="html"><![CDATA[<p>完整的代码已经上传 Github，<a href="https://github.com/southerncross/vue-express-dev-boilerplate" target="_blank" rel="external">点击访问</a></p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-__u4E3A_u524D_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177_u548C_u8D44_u6E90_u7BA1_u7406_u5DE5_u5177"><a href="#1-__u4E3A_u524D_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177_u548C_u8D44_u6E90_u7BA1_u7406_u5DE5_u5177" class="headerlink" title="1. 为前端选择合适的预处理工具和资源管理工具"></a>1. 为前端选择合适的预处理工具和资源管理工具</h3><p>预处理工具又分为 js 预处理工具和 css 预处理工具。Javascript 一直以来最为人诟病的一点就是缺乏原生的模块机制，所有 js 代码文件在被 html 页面引入后将共用同一个命名空间。所以才出现了各种“标准”尝试解决这个问题，但他们都不是原生的，需要额外的工具对代码进行特殊处理。虽然 ES6 终于引入了模块机制，但以现在的浏览器支持程度，还不足以“毫无顾虑地随拿随用”。所以 js 预处理工具最主要的工作就是帮助解决 js 的模块问题。而 css 预处理工具则很好理解，就是把 sass，less 或者 stylus 代码翻译、合并成 css 代码。</p>
<p>资源管理工具则是帮我们管理前端所需的各种资源文件（比如 css、js、图片、字体等等），便于我们引用。目前常用的解决方法是将他们直接编码进 js 代码中，然后像引用 js 模块一样引用它们。这可比手写各种 url 方便多了。</p>
<p>正如标题所说，我们将采用 Webpack，因为它具备上面所说的所有功能。此外还支持代码热替换，使修改代码后不用刷新页面也能在浏览器中立即看到效果。</p>
<p><img src="http://webpack.github.io/assets/what-is-webpack.png" alt="Webpack schedule"></p>
<h3 id="2-__u4E3A_u540E_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177"><a href="#2-__u4E3A_u540E_u7AEF_u9009_u62E9_u5408_u9002_u7684_u9884_u5904_u7406_u5DE5_u5177" class="headerlink" title="2. 为后端选择合适的预处理工具"></a>2. 为后端选择合适的预处理工具</h3><p>后端面对的都是 js 代码，不需要前端那样的资源管理工具，另外， Node 强迫你使用至少一种模块管理方案（CommonJS 或 ES6 的 import），也不用考虑代码的依赖问题。</p>
<p>所以后端要简单许多，唯一需要考虑的基本上就剩下如何将 ES6 转译成 ES5 了（如果你打算使用 ES6 的话）。目前常用的做法是使用 Babel，你可以用 Babel 命令行工具独立执行编译过程，也可以配置 Babel register 实现代码运行时动态翻译，这对于开发场景而言无疑是最方便的。所以我们选择后一种方式。</p>
<p><img src="https://babeljs.io/images/logo.svg" alt="Babel logo"></p>
<h3 id="3-__u4E3A_u6574_u4E2A_u9879_u76EE_u9009_u62E9_u5408_u9002_u7684_u6D41_u7A0B_u63A7_u5236_u5DE5_u5177"><a href="#3-__u4E3A_u6574_u4E2A_u9879_u76EE_u9009_u62E9_u5408_u9002_u7684_u6D41_u7A0B_u63A7_u5236_u5DE5_u5177" class="headerlink" title="3. 为整个项目选择合适的流程控制工具"></a>3. 为整个项目选择合适的流程控制工具</h3><p>流程控制工具是为了帮助我们管理诸如代码检查、编译、压缩、移动、部署这些任务的，原本我们是通过手敲命令（或者高级一点写个脚本）的方式做，有了流程控制工具以后，只需要提供配置文件和少量代码就可以完成。</p>
<p>目前最流行的解决方案是 gulp。不过，由于我们这里要搭建的是开发环境，没有移动代码、压缩、部署等需求，所以不需要功能强大的 gulp。我们只要用 nodemon 这个工具监听代码变动然后适时重启 server就够了。</p>
<p><img src="https://camo.githubusercontent.com/fd1ea21338ceeef34920e44e97d099f3c47a78c3/687474703a2f2f6e6f64656d6f6e2e696f2f6e6f64656d6f6e2e737667" alt="Nodemon logo"></p>
<h2 id="u6B63_u5F0F_u5F00_u59CB_u642D_u5EFA"><a href="#u6B63_u5F0F_u5F00_u59CB_u642D_u5EFA" class="headerlink" title="正式开始搭建"></a>正式开始搭建</h2><h3 id="1-__u5229_u7528_Express__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528"><a href="#1-__u5229_u7528_Express__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528" class="headerlink" title="1. 利用 Express 脚手架快速搭建应用"></a>1. 利用 Express 脚手架快速搭建应用</h3><p>使用 Express 提供的脚手架工具（<a href="http://expressjs.com/en/starter/generator.html" target="_blank" rel="external">Express application generator</a>）可以在 1s 之内搭建出最基本的应用。</p>
<p>如果你以前还没试过，首先执行下面的命令安装</p>
<p><code>npm install express-generator -g</code></p>
<p>然后执行以下命令生成代码，命令执行过程中需要输入一些参数。</p>
<p><code>express &lt;myapp&gt;</code></p>
<p>完成后的文件结构是这样的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app<span class="class">.js</span></span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package<span class="class">.json</span></span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style<span class="class">.css</span></span><br><span class="line">├── routes</span><br><span class="line">│   ├── index<span class="class">.js</span></span><br><span class="line">│   └── users<span class="class">.js</span></span><br><span class="line">└── views</span><br><span class="line">    ├── error<span class="class">.jade</span></span><br><span class="line">    ├── index<span class="class">.jade</span></span><br><span class="line">    └── layout.jade</span><br></pre></td></tr></table></figure>
<p>但是这个文件结构只是后端代码，要想跟前端代码相结合，需要做一些改动。我们计划最终的文件结构应该是这样的</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line">│   ├── <span class="keyword">client</span></span><br><span class="line">│   └── <span class="keyword">server</span></span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>所以需要将上面自动生成的 Express 代码放到 /src/server/ 路径下。</p>
<p>接下来我们要删除一些用不着的东西以及增加一些缺失的东西。</p>
<p>首先，由于我们打算在前端使用 Vue 框架，并由 Vue-Router 管理大部分路由，后端 Express 仅保留少量的 RESTful API 路由，所以后端不需要复杂的路由设置，那么 routes 文件夹下的内容可以简化成一个 routers.js 文件。</p>
<p>然后，我们需要配置好 Babel register，所以需要在项目跟路径下新增两个文件 <code>.babelrc</code> 和 <code>index.js</code>，内容分别为：</p>
<p>/.babelrc<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">presets</span>": <span class="value">[<span class="string">"es2015"</span>]</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>.babelrc 是 Babel 6.0 必须的文件</p>
<p>/.index.js<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'babel-register'</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">require</span><span class="params">(<span class="string">'./src/server'</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面两句完成 Bebel 注册，它会爬取所有 <code>require</code> 或 <code>import</code> 方式依赖的模块并把它们翻译成 ES5。</p>
<p>自动生成的代码里有个 www 文件，他是 Express 应用的入口文件，我们把它放在 server 路径下并改名为 index.js 以便让上面配置的 Babel register 能正确找到它。</p>
<blockquote>
<p>为什么要改名为 index.js ？这是因为 <code>require(&#39;./src/server&#39;)</code> 在默认情况下会去找 ./src/server/index.js，如果你想用别的名字，那就记得将 Babel register 的配置文件里改为 <code>require(./src/&lt;your entry file&gt;</code>。</p>
</blockquote>
<p>好了，现在后端的事情先暂时告一段落，接下来看看前端。</p>
<h3 id="2-__u5229_u7528_Vue__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528"><a href="#2-__u5229_u7528_Vue__u811A_u624B_u67B6_u5FEB_u901F_u642D_u5EFA_u5E94_u7528" class="headerlink" title="2. 利用 Vue 脚手架快速搭建应用"></a>2. 利用 Vue 脚手架快速搭建应用</h3><p>同样地，推荐使用 Vue 自带的 <a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">template 工具</a>，在 1s 内生成基本代码。</p>
<p>虽然利用这个工具生成的代码的后端就是基于 Express 的，但是后端部分的代码结构太简单，不适合做后续开发。所以建议这里先将 Vue 生成的代码放在另外一个地方，然后按需移动到前面用 Express 生成的代码文件夹里。</p>
<p>首先安装 template 工具</p>
<p><code>npm install -g vue-cli</code></p>
<p>然后执行命令生成代码。命令执行过程中需要输入一些参数</p>
<p><code>vue init webpack &lt;my-project&gt;</code></p>
<p>生成的代码结构是这样的</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── dev-<span class="keyword">server</span>.js         <span class="preprocessor"># development server script</span></span><br><span class="line">│   ├── karma.conf.js         <span class="preprocessor"># unit testing config</span></span><br><span class="line">│   ├── webpack.base.conf.js  <span class="preprocessor"># shared base webpack config</span></span><br><span class="line">│   ├── webpack.dev.conf.js   <span class="preprocessor"># development webpack config</span></span><br><span class="line">│   ├── webpack.prod.conf.js  <span class="preprocessor"># production webpack config</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.js               <span class="preprocessor"># app entry file</span></span><br><span class="line">│   ├── App.vue               <span class="preprocessor"># main app component</span></span><br><span class="line">│   ├── components            <span class="preprocessor"># ui components</span></span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── assets                <span class="preprocessor"># module assets (processed by webpack)</span></span><br><span class="line">│       └── ...</span><br><span class="line">├── <span class="keyword">static</span>                    <span class="preprocessor"># pure static assets (directly copied)</span></span><br><span class="line">├── dist                      <span class="preprocessor"># built files ready for deploy</span></span><br><span class="line">├── test</span><br><span class="line">│   └── unit                  <span class="preprocessor"># unit tests</span></span><br><span class="line">│       ├── <span class="keyword">index</span>.js          <span class="preprocessor"># unit test entry file</span></span><br><span class="line">│       └── ...</span><br><span class="line">├── .babelrc                  <span class="preprocessor"># babel config</span></span><br><span class="line">├── .eslintrc.js              <span class="preprocessor"># eslint config</span></span><br><span class="line">├── <span class="keyword">index</span>.html                <span class="preprocessor"># main html file</span></span><br><span class="line">└── package.json              <span class="preprocessor"># build scripts and dependencies</span></span><br></pre></td></tr></table></figure>
<p>我们发现这里也有一个 .babelrc，内容跟之前自己创建的基本一致，可以忽略它。此外，它还提供了 .eslintrc.js，是为了配合 eslint 检查代码是否符合规范的。这里面的内容很简单，想要偷懒就直接拿过来，觉得定制的规则不太符合自己的习惯的可以另外配置。</p>
<p>然后看到 build 路径下有 3 个 webpack 有关的配置文件，因为我们是要搭建开发环境，所以挑里面的 webpack.base.conf.js 和 webpack.dev.conf.js 就可以，建议把内容合并到一个 webpack.conf.js 文件里，放在项目的根目录下。</p>
<p>之后，基本上就是把 src 目录移动到之前用 Express 创建的 /src/client/，我习惯将所有 js 的入口文件都改为 index.js 所以，这里也可以将 src/client/main.js 改名为 src/client/index.js。</p>
<p>其他的文件先忽略不管。</p>
<p>到这里，前端部分的代码也基本整理完毕了。</p>
<h3 id="3-__u914D_u7F6E_Webpack"><a href="#3-__u914D_u7F6E_Webpack" class="headerlink" title="3. 配置 Webpack"></a>3. 配置 Webpack</h3><p>我们计划让 Webpack 将前端文件打包成一个 build.js 文件，然后放在 /src/server/public/javascripts 中供 jade 模板使用。所以设置好 webpack 的路径部分（其他的保留原来的就好）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'src/client/index.js'</span>),</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.join(__dirname, <span class="string">'src/server/public/javascripts/'</span>),</span><br><span class="line">      publicPath: <span class="string">'/javascripts/'</span>,</span><br><span class="line">      filename: <span class="string">'build.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于如何启动 Webpack，你可以选择单独用一个 shell 窗口运行它，也可以以 Express 中间件的形式提供代理。采用后一种方式，webpack 并不会把打包好的代码生成在磁盘上，而是保留在内存里。我们选择后一种方式，因为更方便。</p>
<blockquote>
<p>只应该在开发环境中以 Express 中间件的形式部署 Webpack</p>
</blockquote>
<p>所以需要修改 /src/server/index.js，关键是增加这几句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">'webpack'</span></span><br><span class="line"><span class="keyword">import</span> webpackDevMiddleware <span class="keyword">from</span> <span class="string">'webpack-dev-middleware'</span></span><br><span class="line"><span class="keyword">import</span> webpackHotMiddleware <span class="keyword">from</span> <span class="string">'webpack-hot-middleware'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../../webpack.config'</span></span><br><span class="line"></span><br><span class="line">const compiler = webpack(config)</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  publicPath: config.output.publicPath,</span><br><span class="line">  stats: &#123; colors: true &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use(webpackHotMiddleware(compiler))</span><br></pre></td></tr></table></figure>
<p>这样每次启动 Express 后，Webpack 中间件会拦截 config.output.publicPath 地址的请求并返回正确的结果，同时，如果被 Webpack 监听的文件发生变动，会立即通知前端产生相应变化。</p>
<h3 id="4-__u914D_u7F6E_Nodemon"><a href="#4-__u914D_u7F6E_Nodemon" class="headerlink" title="4. 配置 Nodemon"></a>4. 配置 Nodemon</h3><p>之前提到过，计划用 Nodemon 启动 server 并监听代码变动。而 Nodemon 默认会监听除了 .git 和 node_modules 路径外的所有 js 代码，因为我们已经有 Webpack 监听前端代码了，所以得做相关配置让 Nodemon 只监听某一块代码。</p>
<p>在项目根路径下新增文件 nodemon.json，内容为</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">verbose</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">  "<span class="attribute">ignore</span>": <span class="value">[<span class="string">"src/server/public/"</span>]</span>,</span><br><span class="line">  "<span class="attribute">events</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">restart</span>": <span class="value"><span class="string">"osascript -e 'display notification \"App restarted due to:\n'$FILENAME'\" with title \"nodemon\"'"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">watch</span>": <span class="value">[<span class="string">"src/server/"</span>]</span>,</span><br><span class="line">  "<span class="attribute">env</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">NODE_ENV</span>": <span class="value"><span class="string">"development"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">ext</span>": <span class="value"><span class="string">"js jade"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中，将 verbose 设置为 true 将打印更丰富的日志信息，对开发很有帮助。</p>
<p>我们选择让 Nodemon 监听 src/server/ 目录，并忽略 src/server/public 目录，因为那里是前端 webpack 生成打包文件的地方。注意我们是以 Express 中间件的形式使用 Webpack，并不会在磁盘上真的产生文件，所以这个 ignore 规则其实可以省略。</p>
<p>别忘了在文件扩展名中增加 jade 类型，因为 Express 使用的是 jade 模板。</p>
<h3 id="5-__u914D_u7F6E_package-json"><a href="#5-__u914D_u7F6E_package-json" class="headerlink" title="5. 配置 package.json"></a>5. 配置 package.json</h3><p>首先在 script 中增加一个命令，用来启动整个应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"nodemon index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，只需要运行 <code>npm run dev</code> 这一个命令就可以启动 server 同时进行开发了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>完整的代码已经上传 Github，<a href="https://github.com/southerncross/vue-express-dev-boilerplate" target="_blank" rel="external">点击访问</a></p>
<h2 i]]>
    </summary>
    
      <category term="express, vue, webpack, node" scheme="http://southerncross.github.io/tags/express-vue-webpack-node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何正确使用h1 h2 h3]]></title>
    <link href="http://southerncross.github.io/2016/02/14/how-to-use-h1-h2-h3/"/>
    <id>http://southerncross.github.io/2016/02/14/how-to-use-h1-h2-h3/</id>
    <published>2016-02-14T13:29:18.000Z</published>
    <updated>2016-02-20T05:50:49.000Z</updated>
    <content type="html"><![CDATA[<p><code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>（以下简称<code>h1~6</code>）是 html 的原生标签，虽然今天并不常用。</p>
<h2 id="h1_7E6__u5E2E_u52A9_u88F8_u5954_u7684_u9875_u9762_u7A7F_u4E0A_u5E95_u88E4"><a href="#h1_7E6__u5E2E_u52A9_u88F8_u5954_u7684_u9875_u9762_u7A7F_u4E0A_u5E95_u88E4" class="headerlink" title="h1~6 帮助裸奔的页面穿上底裤"></a>h1~6 帮助裸奔的页面穿上底裤</h2><p>1995 年 9 月，<a href="https://www.ietf.org/" target="_blank" rel="external">国际互联网工程任务组（IETF）</a> 正式颁布了 超文本标记语言（HTML）的第一个标准 —— <a href="https://tools.ietf.org/html/rfc1866" target="_blank" rel="external">IETF RFC 1866</a>，即 HTML 2.0 。其中就包含了 <code>h1~6</code>。</p>
<blockquote>
<p>Headings: H1 … H6<br>The six heading elements, <h1\> through <h6\>, denote section headings.<br>   Although the order and occurrence of headings is not constrained by<br>   the HTML DTD, documents should not skip levels (for example, from H1<br>   to H3), as converting such documents to other representations is<br>   often problematic.</h6\></h1\></p>
</blockquote>
<p>受限于浏览器的性能以及网络带宽，当时的页面主要是以文字+少量图片的形式呈现的，甚至大部分页面都是裸奔状态（没有设置任何css效果）。这种以文本内容为主的页面其实跟我们今天使用 Markdown 写成的文档比较类似，只需要将重点放在文字的样式上就够了。因而使用 h1~6 的好处就非常明显，因为浏览器针对这些标签都会有特定的样式效果，不用额外书写css也能让页面看上去“美观”。</p>
<p>根据 <a href="https://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">W3C 的 html4 文档标准</a>，h1~6 主要具有下列默认风格：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span>, <span class="tag">h2</span>, <span class="tag">h3</span>, <span class="tag">h4</span>, <span class="tag">h5</span>, <span class="tag">h6</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">unicode-bidi</span>:<span class="value"> embed</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bolder</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">h1</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">2em</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> .<span class="number">67em</span> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">h2</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.5em</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> .<span class="number">75em</span> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">h3</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.17em</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> .<span class="number">83em</span> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">h4</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1.12em</span> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">h5</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> .<span class="number">83em</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1.5em</span> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">h6</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-size</span>:<span class="value"> .<span class="number">75em</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1.67em</span> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>简单来说就是</p>
<ol>
<li><code>h1~6</code> 自带加粗效果</li>
<li><code>h1~3</code> 比普通文本字号大，<code>h4</code> 跟普通文本字号一样，<code>h5~6</code> 比普通文本小</li>
<li><code>h1~6</code> 是 <code>block</code> 元素，自带上下边距</li>
</ol>
<h2 id="h1_7E6__u9ED8_u8BA4_u6837_u5F0F_u7684_u53EF_u7528_u6027_u51E0_u4E4E_u4E3A_u96F6"><a href="#h1_7E6__u9ED8_u8BA4_u6837_u5F0F_u7684_u53EF_u7528_u6027_u51E0_u4E4E_u4E3A_u96F6" class="headerlink" title="h1~6 默认样式的可用性几乎为零"></a>h1~6 默认样式的可用性几乎为零</h2><p>上面也提到了，<code>h1~6</code> 是自带默认效果的，这对早期的裸奔页面非常重要，但是在今天的网页设计中几乎是毫无作用的。因为那些默认效果恰好匹配上页面设计图的概率几乎为零，所以通常你都需要用自己的样式覆盖默认的效果（字号、粗细、上下边距、display 效果，等等等等）。</p>
<p>所以，<strong>不要从样式的角度考虑是否用 h1~6 以及该用他们中的哪一个</strong>。你就当他们跟 <code>p</code> 标签一样没有任何效果吧。</p>
<h2 id="h1_7E6__u7684_u8BED_u4E49_u5316_u6548_u679C_u6781_u5176_u6709_u9650"><a href="#h1_7E6__u7684_u8BED_u4E49_u5316_u6548_u679C_u6781_u5176_u6709_u9650" class="headerlink" title="h1~6 的语义化效果极其有限"></a>h1~6 的语义化效果极其有限</h2><p>大部分人使用 <code>h1~6</code> 想必是因为看中了其语义化标签的特点。</p>
<blockquote>
<p>你看，这里使用 h1，开发人员一眼看过去就知道这是标题，多么清楚。</p>
</blockquote>
<p>这其实是一种自欺欺人的想法。首先，开发人员有必要知道“这是标题”吗？就算知道它是标题，你又能怎样？如果是为了设置样式，还不是得乖乖使用 <code>class</code>。但是既然都已经用到描述能力更强的 <code>class</code>，还有必要纠结 <code>h1~6</code> 仅有的一点点语义信息吗？</p>
<ul>
<li>一个开发者见到 h1，那他能知道什么呢？</li>
<li>一个开发者见到 <code>.settings__user-profile__title</code>，他又能知道什么呢？</li>
</ul>
<p>你完全可以通过合理命名的 <code>class</code> 属性体现“语义化”特性，不但更灵活，而且更有效。</p>
<h2 id="h1_7E6__u5F88_u5BB9_u6613_u88AB_u6EE5_u7528"><a href="#h1_7E6__u5F88_u5BB9_u6613_u88AB_u6EE5_u7528" class="headerlink" title="h1~6 很容易被滥用"></a>h1~6 很容易被滥用</h2><p>既然 <code>h1~6</code> 都表示标题，那么问题来了，什么样的标题应该用 <code>h1</code>，什么样的标题应该用 <code>h2</code>，什么样的标题应该用 <code>h3</code> …</p>
<p>你会发现，当你的页面几乎都是文字的时候，这个问题很好区分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">  <span class="number">1.1</span></span><br><span class="line">  <span class="number">1.2</span></span><br><span class="line">    <span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">    <span class="number">1.2</span><span class="number">.2</span></span><br><span class="line">    <span class="number">1.2</span><span class="number">.3</span></span><br><span class="line">  <span class="number">1.3</span></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">  <span class="number">2.1</span></span><br><span class="line">  <span class="number">2.2</span></span><br><span class="line">  <span class="number">2.3</span></span><br></pre></td></tr></table></figure>
<p>上面的文章结构可以跟 <code>h1~6</code> 无缝衔接。</p>
<p>可是当你的页面充满了表格、弹窗、下拉菜单、导航条、图片、按钮的时候，你很难整理出像上面一样清晰的文档结构。此时，问题的答案就没有那么显然了。导航的标题，图片的标题、表格的标题、表单的标题、弹窗的标题、下拉的标题…</p>
<p>你很快就会迷失在“这个标题应该用 <code>h1~6</code> 之中的哪一个”的问题里面。</p>
<p>到最后，这些标签分散在各个页面里，你也不清楚自己在哪些地方用到了 <code>h1</code>， <code>h2</code>，<code>h3</code>。于是你开始自暴自弃，看心情使用，<code>h1~6</code> 的组织变得一团糟。</p>
<p>假如开发者是一个团队，那上面的情况还要严重许多，为了规范代码，你不得不整理一份编码文档，用来规定什么地方用什么标签，除了督促成员遵守，还得定期更新维护。稍微一不小心，<code>h1~6</code> 就会混乱起来。</p>
<blockquote>
<p>使用一门灵活的语言对于个人开发是很方便的，但是对于团队开发将是灾难性的，因为你不得不在语法之外规定一长串的“编码规范”以保证整个团队产出的代码风格一致。语言本身语法的“约束”越少，“编码规范”就越长。</p>
</blockquote>
<p>如果彻底不用 <code>h1~6</code> 或者仅保留 <code>h1</code>，那么上面的问题就立即被解决了。这也是为什么有些大公司只允许使用 <code>h1</code> 的原因。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p><code>h1~6</code> 仅适用于以文字内容为主的页面，对于其他页面，顶多用到 <code>h1</code> 就够了。让 <code>h2~6</code> 见鬼去吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>h1</code>，<code>h2</code>，<code>h3</code>，<code>h4</code>，<code>h5</code>，<code>h6</code>（以下简称<code>h1~6</code>）是 html 的原生标签，虽然今天并不]]>
    </summary>
    
      <category term="front-end" scheme="http://southerncross.github.io/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Meteor七牛客户端上传的例子]]></title>
    <link href="http://southerncross.github.io/2016/02/01/meteor-qiniu-client-upload-example/"/>
    <id>http://southerncross.github.io/2016/02/01/meteor-qiniu-client-upload-example/</id>
    <published>2016-02-01T08:44:53.000Z</published>
    <updated>2016-02-01T14:43:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>安装七牛 nodejs SDK</p>
<p>因为 Meteor 无法使用原生 npm 包，必须借助 <a href="https://github.com/meteorhacks/npm" target="_blank" rel="external">meteorhacks</a> 才能使用，所以确保已经安装了 meteorhacks 。</p>
<p>首先安装 meteorhacks</p>
<p><code>meteor add meteorhacks:npm</code></p>
<p>然后在项目根路径下编辑 packages.json 文件，增加七牛的 node SDK</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">qiniu</span>": <span class="value"><span class="string">"6.1.9"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>完成后重启 meteor 服务器即可</p>
<p><code>meteor</code></p>
<blockquote>
<p>偶尔 meteorhacks 会出现无法正确加载 node modules 的问题，如果是这样尝试先卸载 meteorhacks 然后重新安装。</p>
</blockquote>
</li>
<li><p>安装七牛 js SDK</p>
<blockquote>
<p>前面安装的 nodejs SDK 是后端依赖，现在安装的 js SDK 是前端依赖，二者不要搞混了。</p>
</blockquote>
<p>根据七牛文档说明，需要下载两个东西：plupload 和 七牛的 js SDK，下载后放在相应的路径下（比如 public ）然后让 index.html 引入即可。</p>
</li>
<li><p>安装 Meteor iron router</p>
<p>因为七牛上传需要服务器端和前端配合，需要配置好路由，所以要安装 <a href="https://github.com/iron-meteor/iron-router" target="_blank" rel="external">iron router</a></p>
<p><code>meteor add iron:router</code></p>
</li>
</ol>
<h2 id="u4E03_u725B_u4E0A_u4F20_u6D41_u7A0B"><a href="#u4E03_u725B_u4E0A_u4F20_u6D41_u7A0B" class="headerlink" title="七牛上传流程"></a>七牛上传流程</h2><p>首先再回顾一下七牛官方教程中提到的文件上传流程</p>
<img src="/2016/02/01/meteor-qiniu-client-upload-example/qiniu-upload-flow.png" alt="七牛上传流程" title="七牛上传流程">
<blockquote>
<p>业务服务器指的是 Meteor 所在服务器</p>
</blockquote>
<p>其中，步骤 1 和 2 需要借助前面安装的七牛 nodejs SDK 实现，而步骤 3 和 4 则需要借助 js SDK实现。</p>
<h2 id="u670D_u52A1_u5668_u7AEF"><a href="#u670D_u52A1_u5668_u7AEF" class="headerlink" title="服务器端"></a>服务器端</h2><p>首先从服务器端开始，其实要做的就一件事：响应 token 请求</p>
<p>利用 iron router，配置好相应路由 method</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qiniu = Meteor.npmRequire(<span class="string">'qiniu'</span>);</span><br><span class="line">qiniu.conf.ACCESS_KEY = <span class="string">'你的 ACCESS_KEY'</span>;</span><br><span class="line">qiniu.conf.SECRET_KEY = <span class="string">'你的 SECRET_KEY'</span>;</span><br><span class="line"></span><br><span class="line">Router.route(<span class="string">'/api/uptoken'</span>, &#123; where: <span class="string">'server'</span> &#125;)</span><br><span class="line">.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">this</span>.response;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="keyword">new</span> qiniu.rs.PutPolicy(<span class="string">'你的bucket名字'</span>);</span><br><span class="line"></span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.end(<span class="built_in">JSON</span>.stringify(&#123; uptoken: token &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样，前端就可以通过向 ‘/api/uptoken’ 这个 url 请求 upload token 了</p>
<p>当然，这里只是出于演示的目的，简化了 token 的生成过程。具体的细节请参考七牛的 <a href="http://developer.qiniu.com/docs/v6/sdk/nodejs-sdk.html" target="_blank" rel="external">nodejs SDK 文档</a></p>
<h2 id="u5BA2_u6237_u7AEF"><a href="#u5BA2_u6237_u7AEF" class="headerlink" title="客户端"></a>客户端</h2><p>客户端有两件事要做</p>
<ol>
<li><p>向后端请求 upload token</p>
<p>只需要向之前定义的 url 发送 GET 请求即可。方法有很多种，这里就不罗嗦了。</p>
</li>
<li><p>拿着 upload token 向七牛服务器上传文件</p>
<p>这里要用到七牛的 js SDK。因为只是演示，所以就直接复制 js SDK 文档上的代码了。</p>
<p>别忘了在 html 页面中放置一个 id 为 pickfiles 的 button ，而且其父容器 id 为 container。这是 plupload 所需要的，你也可以在 SDK 的配置中自定义 id 。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Qiniu.uploader(&#123;</span><br><span class="line">  runtimes: <span class="string">'html5,html4'</span>,          <span class="comment">//上传模式,依次退化</span></span><br><span class="line">  browse_button: <span class="string">'pickfiles'</span>,       <span class="comment">//上传选择的点选按钮，**必需**</span></span><br><span class="line">  uptoken_url: <span class="string">'/api/uptoken'</span>,      <span class="comment">//Ajax请求upToken的Url，**强烈建议设置**（服务端提供）</span></span><br><span class="line">  domain: <span class="string">'http://你的七牛域名'</span>,      <span class="comment">//bucket 域名，下载资源时用到，**必需**</span></span><br><span class="line">  get_new_uptoken: <span class="literal">false</span>,           <span class="comment">//设置上传文件的时候是否每次都重新获取新的token</span></span><br><span class="line">  container: <span class="string">'container'</span>,           <span class="comment">//上传区域DOM ID，默认是browser_button的父元素，</span></span><br><span class="line">  max_file_size: <span class="string">'100mb'</span>,           <span class="comment">//最大文件体积限制</span></span><br><span class="line">  max_retries: <span class="number">3</span>,                   <span class="comment">//上传失败最大重试次数</span></span><br><span class="line">  dragdrop: <span class="literal">true</span>,                   <span class="comment">//开启可拖曳上传</span></span><br><span class="line">  drop_element: <span class="string">'container'</span>,        <span class="comment">//拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传</span></span><br><span class="line">  chunk_size: <span class="string">'4mb'</span>,                <span class="comment">//分块上传时，每片的体积</span></span><br><span class="line">  auto_start: <span class="literal">true</span>,                 <span class="comment">//选择文件后自动上传，若关闭需要自己绑定事件触发上传,</span></span><br><span class="line">  init: &#123;</span><br><span class="line">    FilesAdded: <span class="function"><span class="keyword">function</span>(<span class="params">up, files</span>) </span>&#123;</span><br><span class="line">      plupload.each(files, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 文件添加进队列后,处理相关的事情</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    BeforeUpload: <span class="function"><span class="keyword">function</span>(<span class="params">up, file</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 每个文件上传前,处理相关的事情</span></span><br><span class="line">    &#125;,</span><br><span class="line">    UploadProgress: <span class="function"><span class="keyword">function</span>(<span class="params">up, file</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 每个文件上传时,处理相关的事情</span></span><br><span class="line">    &#125;,</span><br><span class="line">    FileUploaded: <span class="function"><span class="keyword">function</span>(<span class="params">up, file, info</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 每个文件上传成功后,处理相关的事情</span></span><br><span class="line">      <span class="comment">// 其中 info 是文件上传成功后，服务端返回的json，形式如</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//    "hash": "Fh8xVqod2MQ1mocfI4S4KpRL6D98",</span></span><br><span class="line">      <span class="comment">//    "key": "gogopher.jpg"</span></span><br><span class="line">      <span class="comment">//  &#125;</span></span><br><span class="line">      <span class="comment">// 参考http://developer.qiniu.com/docs/v6/api/overview/up/response/simple-response.html</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// var domain = up.getOption('domain');</span></span><br><span class="line">      <span class="comment">// var res = parseJSON(info);</span></span><br><span class="line">      <span class="comment">// var sourceLink = domain + res.key; 获取上传成功后的文件的Url</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">Error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">up, err, errTip</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 上传出错时,处理相关的事情</span></span><br><span class="line">    &#125;,</span><br><span class="line">    UploadComplete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//队列文件处理完毕后,处理相关的事情</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Key: <span class="function"><span class="keyword">function</span>(<span class="params">up, file</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 若想在前端对每个文件的key进行个性化处理，可以配置该函数</span></span><br><span class="line">      <span class="comment">// 该配置必须要在 unique_names: false , save_key: false 时才生效</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> key = <span class="string">""</span>;</span><br><span class="line">      <span class="comment">// do something with key here</span></span><br><span class="line">      <span class="keyword">return</span> key</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="u5927_u529F_u544A_u6210_uFF01"><a href="#u5927_u529F_u544A_u6210_uFF01" class="headerlink" title="大功告成！"></a>大功告成！</h2><p>作完上面的工作后，你就可以上传文件了，赶紧试试吧</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>安装七牛 nodejs SDK]]>
    </summary>
    
  </entry>
  
</feed>
